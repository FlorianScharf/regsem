triple.lik <- extract_log_lik(triple.out)
loo(triple.out)
loo(triple.lik)
library(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
library(rstanmulticore)
library(loo)
wisc <- read.table("C:/Users/RJacobucci/Documents/GitHub/EDM_Labs/2015/wisc4vpe.dat")
wisc <- read.table("C:/Users/jacobucc/Documents/GitHub/EDM_Labs/2015/wisc4vpe.dat")
names(wisc)<- c("V1","V2","V4","V6","P1","P2","P4", "P6", "Moeducat")
X <- wisc[,c("V1","V2","V4","V6")]
data = list()
#data$alpha <- c(1,1,2,2)
X = as.matrix(X)
N <- nrow(X)
dat2 <- list(
N = N,
X = X,
t = 4)
# -----------------------------
#### No Change ###########
# ----------------------------
noChange.mod <-"
data{
int N; // sample size
int t;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[1] FS[N]; // factor scores, matrix of order [N,D]
real sigma; // variance for each variable
real Sd_d;
real M;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
for (i in 1:N){
mu[i,1] = FS[i,1];
for (tt in 2:t){
d[i,tt-1] = 0;
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
for (i in 1:N){
FS[i] ~ normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
noChange.out=stan(model_code=noChange.mod,iter=5000,warmup=2000,
data = dat2,chains=1,
pars=c("sigma","M","Sd_d","log_lik"))
noChange.out
noChange.lik <- extract_log_lik(noChange.out)
loo(noChange.lik)
# ----------------------------------
# Proportional Change
# ---------------------------------
proportional.mod <-"
data{
int N; // sample size
int t;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[1] FS[N]; // factor scores, matrix of order [N,D]
real sigma; // variance for each variable
real Sd_d;
real M;
real pi;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
for (i in 1:N){
mu[i,1] = FS[i,1];
for (tt in 2:t){
d[i,tt-1] = pi*mu[i,tt-1];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
pi ~ normal(0,1);
for (i in 1:N){
FS[i] ~ normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
proportional.out=stan(model_code=proportional.mod,iter=5000,warmup=2000,
data = dat2,chains=1,
pars=c("sigma","M","Sd_d","pi","log_lik"))
proportional.out
proportional.lik <- extract_log_lik(proportional.out)
loo(proportional.lik)
# -------------------------------------
# Constant Change
# -------------------------------------
dat3 <- list(
N = N,
X = X,
t = 4,
alpha=c(1,1,2,2))
constant.mod <-"
data{
int N; // sample size
int t;
vector[t] alpha;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[2] FS[N]; // factor scores, matrix of order [N,D]
cholesky_factor_cov[2] Rho; // correlation matrix between factors
real sigma; // variance for each variable
vector[2] M;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
matrix[2,2] Sd_d;
Sd_d = multiply_lower_tri_self_transpose(Rho);
for (i in 1:N){
mu[i,1] = FS[i,1];
for (tt in 2:t){
d[i,tt-1] = alpha[tt]*FS[i,2];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
for (i in 1:N){
FS[i] ~ multi_normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
constant.out=stan(model_code=constant.mod,iter=5000,warmup=2000,
data = dat3,chains=1,
pars=c("sigma","M","Sd_d","log_lik"))
constant.out
constant.lik <- extract_log_lik(constant.out)
loo(constant.lik)
# -----------------------------------------
# Dual Change
# -----------------------------------------
dual.mod <-"
data{
int N; // sample size
int t;
vector[t] alpha;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[2] FS[N]; // factor scores, matrix of order [N,D]
cholesky_factor_cov[2] Rho; // correlation matrix between factors
real sigma; // variance for each variable
vector[2] M;
real pi;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
matrix[2,2] Sd_d;
Sd_d = multiply_lower_tri_self_transpose(Rho);
for (i in 1:N){
mu[i,1] = FS[i,1];
for (tt in 2:t){
d[i,tt-1] = pi*mu[i,tt-1] + alpha[tt]*FS[i,2];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
pi ~ normal(0,.5);
for (i in 1:N){
FS[i] ~ multi_normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
dual.out=stan(model_code=dual.mod,iter=5000,warmup=2000,
data = dat3,chains=1,
pars=c("sigma","M","Sd_d","pi","log_lik"))
dual.out
dual.lik <- extract_log_lik(dual.out)
loo(dual.lik)
# --------------------------------------------------
# Changes to Changes
# --------------------------------------------------
changes.mod <-"
data{
int N; // sample size
int t;
vector[t] alpha;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[2] FS[N]; // factor scores, matrix of order [N,D]
cholesky_factor_cov[2] Rho; // correlation matrix between factors
real sigma; // variance for each variable
vector[2] M;
real pi;
real phi;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
matrix[2,2] Sd_d;
Sd_d = multiply_lower_tri_self_transpose(Rho);
for (i in 1:N){
mu[i,1] = FS[i,1];
d[i,1] = pi*mu[i,1] + alpha[2]*FS[i,2];
mu[i,2] = d[i,1]+mu[i,1];
for (tt in 3:t){
d[i,tt-1] = pi*mu[i,tt-1] + alpha[tt]*FS[i,2] + phi*d[i,tt-2];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
pi ~ normal(0,1);
phi ~ normal(0,1);
for (i in 1:N){
FS[i] ~ multi_normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
changes.out=stan(model_code=changes.mod,iter=5000,warmup=2000,
data = dat3,chains=1,
pars=c("sigma","M","Sd_d","pi","phi","log_lik"))
changes.out
changes.lik <- extract_log_lik(changes.out)
loo(changes.lik)
# ---------------------------------
# Triple Change
# ---------------------------------
triple.mod <-"
data{
int N; // sample size
int t;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[2] FS[N]; // factor scores, matrix of order [N,D]
cholesky_factor_cov[2] Rho; // correlation matrix between factors
real sigma; // variance for each variable
vector[2] M;
vector[2] alpha;
real pi;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
matrix[2,2] Sd_d;
Sd_d = multiply_lower_tri_self_transpose(Rho);
for (i in 1:N){
mu[i,1] = FS[i,1];
d[i,1] = pi*mu[i,1] + 1*FS[i,2];
mu[i,2] = d[i,1]+mu[i,1];
for (tt in 3:t){
d[i,tt-1] = pi*mu[i,tt-1] + alpha[tt-2]*FS[i,2];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
pi ~ normal(0,.5);
alpha ~ normal(2,3);
for (i in 1:N){
FS[i] ~ multi_normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
triple.out=stan(model_code=triple.mod,iter=5000,warmup=2000,
data = dat2,chains=1,
pars=c("sigma","M","Sd_d","pi","alpha","log_lik"))
triple.out
triple.lik <- extract_log_lik(triple.out)
loo(triple.lik)
save.image("C:/Users/RJacobucci/Documents/GitHub/LCS_alternate/stanLCSmods.RData")
library(regsem)
library(regsem)
library(regsem)
library(regsem)
xx = list()
for(i in 1:100){
xx[i] = paste("x", i, sep = "")
}
uu = list()
for(i in 1:length(xx)){
uu[i] = paste("0*",xx[i],sep="")
}
reg.list = paste(uu,collapse="+")
sim.list = list()
sim.list[[1]] = "f1 =~ y1 + 0.8*y2 + 1.2*y3 + 0.8*y4 + 0.5*y5 + 1.5*y6
"
sim.list[[2]] = "
f1 ~ 1*x1000 + 1*x1001 + 1*x1002 + 1*x1003 + 1*x1004 + 1*x1005
"
sim.list[[3]] = paste(paste("f1"," ~ "), reg.list)
pop.mod = " "
for(i in 1:length(sim.list)){
pop.mod = paste(pop.mod,sim.list[[i]],sep="\n")
}
reg.list2 = paste(xx,collapse="+")
run.list = list()
run.list[[1]] = "f1 =~ y1 + y2 + y3 + y4 + y5 + y6
"
run.list[[2]] = paste(paste("f1"," ~ "), reg.list2)
run.list[[3]] = "
f1 ~ x1000 + x1001 + x1002 + x1003 + x1004 + x1005
"
run.mod = " "
for(k in 1:length(run.list)){
run.mod = paste(run.mod,run.list[[k]],sep="\n")
}
dat <- simulateData(pop.mod,sample.nobs=200,fixed.x=TRUE)
lav.out <- try(lavaan::sem(run.mod,dat,fixed.x=TRUE),silent=TRUE)
library(regsem)
library(regsem)
library(regsem)
xx = list()
for(i in 1:100){
xx[i] = paste("x", i, sep = "")
}
uu = list()
for(i in 1:length(xx)){
uu[i] = paste("0*",xx[i],sep="")
}
reg.list = paste(uu,collapse="+")
sim.list = list()
sim.list[[1]] = "f1 =~ y1 + 0.8*y2 + 1.2*y3 + 0.8*y4 + 0.5*y5 + 1.5*y6
"
sim.list[[2]] = "
f1 ~ 1*x1000 + 1*x1001 + 1*x1002 + 1*x1003 + 1*x1004 + 1*x1005
"
sim.list[[3]] = paste(paste("f1"," ~ "), reg.list)
pop.mod = " "
for(i in 1:length(sim.list)){
pop.mod = paste(pop.mod,sim.list[[i]],sep="\n")
}
reg.list2 = paste(xx,collapse="+")
run.list = list()
run.list[[1]] = "f1 =~ y1 + y2 + y3 + y4 + y5 + y6
"
run.list[[2]] = paste(paste("f1"," ~ "), reg.list2)
run.list[[3]] = "
f1 ~ x1000 + x1001 + x1002 + x1003 + x1004 + x1005
"
run.mod = " "
for(k in 1:length(run.list)){
run.mod = paste(run.mod,run.list[[k]],sep="\n")
}
dat <- simulateData(pop.mod,sample.nobs=200,fixed.x=TRUE)
lav.out <- try(lavaan::sem(run.mod,dat,fixed.x=TRUE),silent=TRUE)
reg.out <- cv_regsem(lav.out,n.lambda=5,jump=0.05,mult.start=FALSE,max.iter=500,
type="lasso",pars_pen=c(6:111))
reg.out <- cv_regsem(lav.out,n.lambda=5,jump=0.05,mult.start=FALSE,max.iter=500,
type="enet",pars_pen=c(6:111),alpha=0.5)
reg.out2 <- cv_regsem(lav.out,n.lambda=5,jump=0.05,mult.start=FALSE,max.iter=500,
type="enet",pars_pen=c(6:111),alpha=0.5)
reg.out2[[2]]
reg.out1[[2]]
reg.out1 <- cv_regsem(lav.out,n.lambda=5,jump=0.05,mult.start=FALSE,max.iter=500,
type="lav",pars_pen=c(6:111))
reg.out1 <- cv_regsem(lav.out,n.lambda=5,jump=0.05,mult.start=FALSE,max.iter=500,
type="lasso",pars_pen=c(6:111))
reg.out[[2]]
reg.out2[[1]]
library(lavaan)
library(semPlot)
library(semTools)
#HS <- HolzingerSwineford1939
#mod <- "
#f1 =~ x1 + x2 + x3 + x4 + x5 + x6
#f2 =~ x7 + x8 + x9 + x4 + x5 + x6
#"
#out <- cfa(mod,HS)
#semPaths(out)
sim.mod <- "
i =~ 1*x1 + 1*x2 + 1*x3 + 1*x4
s =~ 0*x1 + 1*x2 + 2*x3 + 3*x4
i ~ 1*c1 + .2*c2 + 0*c3 + 0*c4 + 0*c5 + 0*c6 + 0*c7 + 0*c8+ 0*c9+ 0*c10
s ~ 1*c1 + .2*c2 + 0*c3 + 0*c4 + 0*c5 + 0*c6 + 0*c7 + 0*c8+ 0*c9+ 0*c10"
dat <- simulateData(sim.mod,model.type="growth",sample.nobs=80,seed=1234)
mod1 <- "
i =~ 1*x1 + 1*x2 + 1*x3 + 1*x4
s =~ x1 + 1*x2 + 2*x3 + 3*x4
i ~ c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8+ c9+ c10
s ~ c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8+ c9+ c10
"
out <- growth(mod1,dat,fixed.x=T)
summary(out)
fitmeasures(out)
semPaths(out, whatLabels="est",intercepts=FALSE,residuals=TRUE,exoCov=FALSE)
library(regsem)
extractMatrices(out)$A
?cv_regsem
reg.out <- cv_regsem(out,pars_pen=c(1:20),type="lasso,n.lambda=40,mult.start=FALSE,)
reg.out <- cv_regsem(out,pars_pen=c(1:20),type="lasso",n.lambda=40,mult.start=FALSE,)
reg.out <- cv_regsem(out,pars_pen=c(1:20),type="lasso",n.lambda=40,mult.start=FALSE)
reg.out
reg.out <- cv_regsem(out,pars_pen=c(1:20),type="lasso",n.lambda=40,mult.start=FALSE,jump=.01)
reg.out
reg.out2 <- cv_regsem(out,pars_pen=c(1:20),type="alasso",n.lambda=40,mult.start=FALSE,jump=.01)
?regsem
reg.out2 <- cv_regsem(out,pars_pen=c(1:20),type="scad",n.lambda=40,mult.start=FALSE,jump=.01)
reg.out2
reg.out
reg.out2
reg.out2
reg.out2 <- cv_regsem(out,pars_pen=c(1:20),type="scad",n.lambda=40,mult.start=FALSE,jump=.1)
reg.out2
reg.out2 <- cv_regsem(out,pars_pen=c(1:20),type="scad",n.lambda=40,mult.start=FALSE,jump=.05)
warnings()
reg.out3 <- cv_regsem(out,pars_pen=c(1:20),type="mcp",n.lambda=40,mult.start=FALSE,jump=.05)
reg.out3
reg.out3 <- cv_regsem(out,pars_pen=c(1:20),type="mcp",n.lambda=40,mult.start=FALSE,jump=.1)
reg.out3
reg.out3 <- cv_regsem(out,pars_pen=c(1:20),type="mcp",n.lambda=40,mult.start=FALSE,jump=.2)
reg.out3
reg.out4 <- cv_regsem(out,pars_pen=c(1:20),type="alasso",n.lambda=40,mult.start=FALSE,jump=.01)
traceback()
reg.out5 <- cv_regsem(out,pars_pen=c(1:20),type="enet",n.lambda=40,mult.start=FALSE,jump=.2,alpha=.5)
reg.out5
reg.out5 <- cv_regsem(out,pars_pen=c(1:20),type="enet",n.lambda=40,mult.start=FALSE,jump=.01,alpha=.5)
reg.out5
reg.out5 <- cv_regsem(out,pars_pen=c(1:20),type="enet",n.lambda=40,mult.start=FALSE,jump=.05,alpha=.5)
reg.out5
reg.out5 <- cv_regsem(out,pars_pen=c(1:20),type="enet",n.lambda=40,mult.start=FALSE,jump=.1,alpha=.5)
reg.out5
reg.out5 <- cv_regsem(out,pars_pen=c(1:20),type="enet",n.lambda=40,mult.start=FALSE,jump=.1,alpha=.8)
reg.out5
library(regsem)
library(regsem)
reg.out5 <- cv_regsem(out,pars_pen=c(1:20),type="enet",n.lambda=40,mult.start=FALSE,jump=.1,alpha=.8)
reg.out5
reg.out5 <- cv_regsem(out,pars_pen=c(1:20),type="enet",n.lambda=40,mult.start=FALSE,jump=.1,alpha=.1)
reg.out5
library(regsem)
library(regsem)
reg.out5 <- cv_regsem(out,pars_pen=c(1:20),type="enet",n.lambda=40,mult.start=FALSE,jump=.1,alpha=.5)
reg.out5
library(regsem)
library(regsem)
install.packages("~/GitHub/regsem_0.7.0.tar.gz", repos = NULL, type = "source")
tools::package_native_routine_registration_skeleton(".")
library("tools", lib.loc="C:/Program Files/R/R-3.3.2/library")
tools::package_native_routine_registration_skeleton(".")
tools::package_native_routine_registration_skeleton("regsem")
install.packages("lavaan")
