extractMatrices(lav.out)
reg.out3 <- cv_regsem(lav.out,n.lambda=45,type="ridge",jump=0.003,multi.iter=200,
pars_pen=c(3:5,8:10,13:15),warm.start=F,gradFun="none",
nlminb.control= list(abs.tol=1e-6,
iter.max=60000,
eval.max=60000,
rel.tol=1e-6,
x.tol=1e-6,xf.tol=1e-6,
xf.tol=1e-6))
conv <- reg.out3[[2]][,"conv"] == 0
conv[1] <- FALSE
# plot trajectories
coef.mat <- reg.out3[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
#for(i in 1:ncol(coef.mat)){
#  coef.mat2[,i] <- coef.mat2[,i]/coef.mat2[1,i]
#}
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.1,.42),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
coef.mat <- reg.out3[[1]][conv,c(3:5,8:10,13:15)]
coef.mat2 <- coef.mat
#for(i in 1:ncol(coef.mat)){
#  coef.mat2[,i] <- coef.mat2[,i]/coef.mat2[1,i]
#}
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.1,.42),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
mod <- "
f1 =~ 1*x1 + x2 + x3 + x7 + x8 + x9
f2 =~ NA*x1 + x2 + x3 + 1*x4 + x5 + x6
f3 =~ NA*x4 + x5 + x6 + 1*x7 + x8 + x9
"
lav.out <- cfa(mod,HS,meanstructure=T,do.fit = T,orthogonal=TRUE)
summary(lav.out)
reg.out2 <- cv_regsem(lav.out,n.lambda=45,type="lasso",jump=0.003,multi.iter=200,
pars_pen=c(3:8,11:13),warm.start=F,
nlminb.control= list(abs.tol=1e-6,
iter.max=60000,
eval.max=60000,
rel.tol=1e-6,
x.tol=1e-6,xf.tol=1e-6,
xf.tol=1e-6))
summary(lav.out)
lav.out <- cfa(mod,HS,meanstructure=T,do.fit = T)
summary(lav.out)
reg.out <- multi_optim(lav.out,max.try=100,type="lasso",verbose=T,
lambda=0.02,pars_pen=c(3:8,11:13),warm.start=F,
nlminb.control= list(abs.tol=1e-4,
iter.max=60000,
eval.max=60000,
rel.tol=1e-6,
x.tol=1e-6,xf.tol=1e-6,
xf.tol=1e-6))
summary(reg.out)
summary(reg.out)
mod <- "
f1 =~ 1*x1 + x2 + x3 + x7 + x8 + x9
f2 =~ NA*x1 + x2 + x3 + 1*x4 + x5 + x6
f3 =~ NA*x4 + x5 + x6 + 1*x7 + x8 + x9
"
lav.out <- cfa(mod,HS,meanstructure=T,do.fit = T)
summary(lav.out)
#lav.out <- efaUnrotate(HS,3)
extractMatrices(lav.out)
library(lavaan);library(blavaan);library(regsem);library(modeest)
library(semTools)
HS <- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod <- "
f1 =~ 1*x1 + x2 + x3 + x7 + x8 + x9
f2 =~ NA*x1 + x2 + x3 + 1*x4 + x5 + x6
f3 =~ NA*x4 + x5 + x6 + 1*x7 + x8 + x9
"
lav.out <- cfa(mod,HS,meanstructure=T,do.fit = T)
summary(lav.out)
reg.out2 <- cv_regsem(lav.out,n.lambda=45,type="lasso",jump=0.003,multi.iter=200,
pars_pen=c(3:8,11:13),warm.start=F,
nlminb.control= list(abs.tol=1e-6,
iter.max=60000,
eval.max=60000,
rel.tol=1e-6,
x.tol=1e-6,xf.tol=1e-6,
xf.tol=1e-6))
save.image("C:/Users/RJacobucci/Documents/GitHub/SparseBayesSEM/hs_regsemLasso.Rdata")
reg.out2[[2]]
conv <- reg.out2[[2]][,"conv"] == 0
#conv <- rep(TRUE,45)
#conv[1] <- FALSE # Need a little penalty
# plot trajectories
coef.mat <- reg.out2[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
#for(i in 1:ncol(coef.mat)){
#  coef.mat2[,i] <- coef.mat2[,i]/coef.mat2[1,i]
#}
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.1,.42),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
reg.out2[[1]][conv,c(3:8,11:13)]
conv[1] <- FALSE # Need a little penalty
# plot trajectories
coef.mat <- reg.out2[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
#for(i in 1:ncol(coef.mat)){
#  coef.mat2[,i] <- coef.mat2[,i]/coef.mat2[1,i]
#}
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.1,.42),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
coef.mat
conv[1] <- FALSE; conv[11] <- FALSE # Need a little penalty
# plot trajectories
coef.mat <- reg.out2[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
#for(i in 1:ncol(coef.mat)){
#  coef.mat2[,i] <- coef.mat2[,i]/coef.mat2[1,i]
#}
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.1,.42),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.3,.7),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.5,.6),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
ind <- min(reg.out2[[2]][conv,"BIC"]) == reg.out2[[2]][conv,"BIC"]
abline(v=reg.out2[[2]][ind,"lambda"])
reg.out3 <- cv_regsem(lav.out,n.lambda=45,type="ridge",jump=0.003,multi.iter=200,
pars_pen=c(3:8,11:13),warm.start=F,gradFun="none",
nlminb.control= list(abs.tol=1e-6,
iter.max=60000,
eval.max=60000,
rel.tol=1e-6,
x.tol=1e-6,xf.tol=1e-6,
xf.tol=1e-6))
reg.out3[[1]]
conv <- reg.out3[[2]][,"conv"] == 0
conv[1] <- FALSE
# plot trajectories
coef.mat <- reg.out3[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.5,.6),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
coef.mat
reg.out3[[2]]
conv[1:2] <- FALSE
# plot trajectories
coef.mat <- reg.out3[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.5,.6),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.7,.6),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.7,.6),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
ind <- min(reg.out3[[2]][conv,"BIC"]) == reg.out3[[2]][conv,"BIC"]
ind
abline(v=reg.out3[[2]][conv[ind],"lambda"])
conv[ind]
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.7,.6),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
ind <- min(reg.out3[[2]][conv,"BIC"]) == reg.out3[[2]][conv,"BIC"]
abline(v=reg.out3[[2]][ind,"lambda"])
reg.out3[[2]][conv,"BIC"])
reg.out3[[2]][conv,"BIC"]
reg.out3[[2]]
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.7,.6),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
ind <- which(min(reg.out3[[2]][conv,"BIC"]) == reg.out3[[2]][conv,"BIC"])
ind
abline(v=.06)
reg.out3[[1]]
?cv_regsem
ncol(reg.out2[[1]])
reg.out2 <- cv_regsem(lav.out,n.lambda=45,type="lasso",jump=0.003,multi.iter=200,
pars_pen=c(3:8,11:13),warm.start=F,LB=rep(0,39),
nlminb.control= list(abs.tol=1e-6,
iter.max=60000,
eval.max=60000,
rel.tol=1e-6,
x.tol=1e-6,xf.tol=1e-6,
xf.tol=1e-6))
reg.out3 <- cv_regsem(lav.out,n.lambda=45,type="ridge",jump=0.003,multi.iter=200,
pars_pen=c(3:8,11:13),warm.start=F,gradFun="none",LB=rep(0,39),
nlminb.control= list(abs.tol=1e-6,
iter.max=60000,
eval.max=60000,
rel.tol=1e-6,
x.tol=1e-6,xf.tol=1e-6,
xf.tol=1e-6))
conv <- reg.out3[[2]][,"conv"] == 0
conv[1:2] <- FALSE
# plot trajectories
coef.mat <- reg.out3[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
#for(i in 1:ncol(coef.mat)){
#  coef.mat2[,i] <- coef.mat2[,i]/coef.mat2[1,i]
#}
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.7,.6),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.1,.8),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
reg.out3[[1]]
reg.out3 <- cv_regsem(lav.out,n.lambda=45,type="ridge",jump=0.003,multi.iter=200,
pars_pen=c(3:8,11:13),warm.start=F,gradFun="none",LB=rep(-.2,39),
nlminb.control= list(abs.tol=1e-6,
iter.max=60000,
eval.max=60000,
rel.tol=1e-6,
x.tol=1e-6,xf.tol=1e-6,
xf.tol=1e-6))
#reg.out2[[2]][-c(12:20),]
#reg.out2[[1]][11,]
conv <- reg.out3[[2]][,"conv"] == 0
conv[1:2] <- FALSE
# plot trajectories
coef.mat <- reg.out3[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
#for(i in 1:ncol(coef.mat)){
#  coef.mat2[,i] <- coef.mat2[,i]/coef.mat2[1,i]
#}
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.1,.8),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.2,.8),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
reg.out3 <- cv_regsem(lav.out,n.lambda=45,type="ridge",jump=0.003,multi.iter=200,
pars_pen=c(3:8,11:13),warm.start=F,gradFun="none",LB=rep(-.3,39),
nlminb.control= list(abs.tol=1e-6,
iter.max=60000,
eval.max=60000,
rel.tol=1e-6,
x.tol=1e-6,xf.tol=1e-6,
xf.tol=1e-6))
#reg.out2[[2]][-c(12:20),]
#reg.out2[[1]][11,]
conv <- reg.out3[[2]][,"conv"] == 0
conv[1:2] <- FALSE
# plot trajectories
coef.mat <- reg.out3[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
#for(i in 1:ncol(coef.mat)){
#  coef.mat2[,i] <- coef.mat2[,i]/coef.mat2[1,i]
#}
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.3,.8),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
reg.out3 <- cv_regsem(lav.out,n.lambda=45,type="ridge",jump=0.003,multi.iter=200,
pars_pen=c(3:8,11:13),warm.start=F,gradFun="none",#LB=rep(-.3,39),
nlminb.control= list(abs.tol=1e-6,
iter.max=60000,
eval.max=60000,
rel.tol=1e-6,
x.tol=1e-6,xf.tol=1e-6,
xf.tol=1e-6))
#reg.out2[[2]][-c(12:20),]
#reg.out2[[1]][11,]
conv <- reg.out3[[2]][,"conv"] == 0
conv[1:2] <- FALSE
# plot trajectories
coef.mat <- reg.out3[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
#for(i in 1:ncol(coef.mat)){
#  coef.mat2[,i] <- coef.mat2[,i]/coef.mat2[1,i]
#}
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.6,.8),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
reg.out3[[3]]
reg.out3[[2]]
reg.out3[[1]]
conv[1:5] <- FALSE
conv <- reg.out3[[2]][,"conv"] == 0
conv[1:5] <- FALSE
# plot trajectories
coef.mat <- reg.out3[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
coef.mat2
conv <- reg.out3[[2]][,"conv"] == 0
conv[1:2] <- FALSE
# plot trajectories
coef.mat <- reg.out3[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
coef.mat2
conv <- reg.out3[[2]][,"conv"] == 0
conv[1:5] <- FALSE
# plot trajectories
coef.mat <- reg.out3[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
#for(i in 1:ncol(coef.mat)){
#  coef.mat2[,i] <- coef.mat2[,i]/coef.mat2[1,i]
#}
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.6,.8),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
ind <- which(min(reg.out3[[2]][conv,"BIC"]) == reg.out3[[2]][conv,"BIC"])
ind
reg.out3[[2]]
abline(v=.06)
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.4,.6),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
ind <- which(min(reg.out3[[2]][conv,"BIC"]) == reg.out3[[2]][conv,"BIC"])
abline(v=.06)
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.4,.5),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
ind <- which(min(reg.out3[[2]][conv,"BIC"]) == reg.out3[[2]][conv,"BIC"])
abline(v=.06)
t2[,i]/coef.mat2[1,i]
#}
plot(reg.out3[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.4,.7),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out3[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
ind <- which(min(reg.out3[[2]][conv,"BIC"]) == reg.out3[[2]][conv,"BIC"])
abline(v=.06)
HS <- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod <- "
f1 =~ 1*x1 + x2 + x3 + x7 + x8 + x9
f2 =~ NA*x1 + x2 + x3 + 1*x4 + x5 + x6
f3 =~ NA*x4 + x5 + x6 + 1*x7 + x8 + x9
"
lav.out <- cfa(mod,HS,meanstructure=T,do.fit = T)
summary(lav.out)
reg.out2 <- cv_regsem(lav.out,n.lambda=45,type="lasso",jump=0.003,multi.iter=200,
pars_pen=c(3:8,11:13),warm.start=F,#LB=rep(0,39),
nlminb.control= list(abs.tol=1e-6,
iter.max=60000,
eval.max=60000,
rel.tol=1e-6,
x.tol=1e-6,xf.tol=1e-6,
xf.tol=1e-6))
save.image("C:/Users/RJacobucci/Documents/GitHub/SparseBayesSEM/hs_regsemLasso.Rdata")
reg.out2[[2]]
conv <- reg.out2[[2]][,"conv"] == 0
#conv <- rep(TRUE,45)
conv[1] <- FALSE; conv[23] <- FALSE # Need a little penalty
# plot trajectories
coef.mat <- reg.out2[[1]][conv,c(3:8,11:13)]
coef.mat2 <- coef.mat
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.5,.6),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
ind <- min(reg.out2[[2]][conv,"BIC"]) == reg.out2[[2]][conv,"BIC"]
abline(v=reg.out2[[2]][ind,"lambda"])
min(reg.out2[[2]][conv,"BIC"])
reg.out2[[2]]
round(reg.out2[[2]][conv,"BIC"])
abline(v=reg.out2[[2]][ind,"lambda"],5)
round(reg.out2[[2]][conv,"BIC"],6)
round(reg.out2[[2]][,"BIC"],6)
round(reg.out2[[2]][,"BIC"],6)
round(reg.out2[[2]][,"BIC"],5)
round(reg.out2[[2]][conv,"BIC"],6)
min(round(reg.out2[[2]][conv,"BIC"],6))
min.bic = min(round(reg.out2[[2]][conv,"BIC"],6))
reg.out2[[2]][conv,"BIC"] == min.bic
ind = reg.out2[[2]][conv,"BIC"] == min.bic
abline(v=reg.out2[[2]][ind,"lambda"])
reg.out2[[2]][ind,"lambda"]
reg.out2[[2]][conv,"BIC"]
min.bic = min(round(reg.out2[[2]][conv,"BIC"],8))
ind = reg.out2[[2]][conv,"BIC"] == min.bic
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.5,.6),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
abline(v=reg.out2[[2]][ind,"lambda"])
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.5,.8),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
#ind <- min(reg.out2[[2]][conv,"BIC"]) == reg.out2[[2]][conv,"BIC"]
min.bic = min(round(reg.out2[[2]][conv,"BIC"],8))
ind = reg.out2[[2]][conv,"BIC"] == min.bic
abline(v=reg.out2[[2]][ind,"lambda"])
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.5,.8),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
#ind <- min(reg.out2[[2]][conv,"BIC"]) == reg.out2[[2]][conv,"BIC"]
min.bic = min(round(reg.out2[[2]][conv,"BIC"],8))
ind = reg.out2[[2]][conv,"BIC"] == min.bic
abline(v=reg.out2[[2]][ind,"lambda"])[1]
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.5,.8),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
#ind <- min(reg.out2[[2]][conv,"BIC"]) == reg.out2[[2]][conv,"BIC"]
min.bic = min(round(reg.out2[[2]][conv,"BIC"],8))
ind = reg.out2[[2]][conv,"BIC"] == min.bic
abline(v=reg.out2[[2]][ind[1],"lambda"])
ind
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.5,.8),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
#ind <- min(reg.out2[[2]][conv,"BIC"]) == reg.out2[[2]][conv,"BIC"]
min.bic = min(round(reg.out2[[2]][conv,"BIC"],8))
ind = reg.out2[[2]][conv,"BIC"] == min.bic
abline(v=reg.out2[[2]][ind,"lambda"])
ind
min.bic
reg.out2[[2]]
round(reg.out2[[2]],5)
round(reg.out2[[2]],4)
round(reg.out2[[2]],6)
round(reg.out2[[2]],7)
which(reg.out2[[2]][,"BIC"] == min.bic)
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.5,.8),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
#ind <- min(reg.out2[[2]][conv,"BIC"]) == reg.out2[[2]][conv,"BIC"]
min.bic = min(round(reg.out2[[2]][conv,"BIC"],8))
ind = reg.out2[[2]][conv,"BIC"] == min.bic
which(reg.out2[[2]][,"BIC"] == min.bic)
abline(v=0.024)
head(HolzingerSwineford1939)
summary(lav.out)
plot(reg.out2[[2]][conv,"lambda"],coef.mat2[,1],ylim=c(-0.5,.8),ylab="Loading",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(ncol(coef.mat2))){
lines(reg.out2[[2]][conv,"lambda"],coef.mat2[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
44*0.003
