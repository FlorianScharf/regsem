}
}
model{
pi ~ normal(0,1);
phi ~ normal(0,1);
for (i in 1:N){
FS[i] ~ multi_normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
"
changes.out=stan(model_code=changes.mod,iter=5000,warmup=2000,
data = dat3,chains=1,
pars=c("sigma","M","Sd_d","pi","phi"))
changes.out
triple.mod <-"
data{
int N; // sample size
int t;
vector[t] alpha;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[2] FS[N]; // factor scores, matrix of order [N,D]
cholesky_factor_cov[2] Rho; // correlation matrix between factors
real sigma; // variance for each variable
vector[2] M;
vector[2] alpha;
real pi;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
matrix[2,2] Sd_d;
Sd_d = multiply_lower_tri_self_transpose(Rho);
for (i in 1:N){
mu[i,1] = FS[i,1];
d[i,1] = pi*mu[i,1] + 1*FS[i,2];
mu[i,2] = d[i,1]+mu[i,1];
for (tt in 3:t){
d[i,tt-1] = pi*mu[i,tt-1] + alpha[tt-2]*FS[i,2];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
pi ~ normal(0,.5);
alpha ~ normal(2,3);
for (i in 1:N){
FS[i] ~ multi_normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
"
triple.out=stan(model_code=triple.mod,iter=5000,warmup=2000,
data = dat2,chains=1,
pars=c("sigma","M","Sd_d","pi"))
triple.mod <-"
data{
int N; // sample size
int t;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[2] FS[N]; // factor scores, matrix of order [N,D]
cholesky_factor_cov[2] Rho; // correlation matrix between factors
real sigma; // variance for each variable
vector[2] M;
vector[2] alpha;
real pi;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
matrix[2,2] Sd_d;
Sd_d = multiply_lower_tri_self_transpose(Rho);
for (i in 1:N){
mu[i,1] = FS[i,1];
d[i,1] = pi*mu[i,1] + 1*FS[i,2];
mu[i,2] = d[i,1]+mu[i,1];
for (tt in 3:t){
d[i,tt-1] = pi*mu[i,tt-1] + alpha[tt-2]*FS[i,2];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
pi ~ normal(0,.5);
alpha ~ normal(2,3);
for (i in 1:N){
FS[i] ~ multi_normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
"
triple.out=stan(model_code=triple.mod,iter=5000,warmup=2000,
data = dat2,chains=1,
pars=c("sigma","M","Sd_d","pi"))
triple.out
triple.out=stan(model_code=triple.mod,iter=5000,warmup=2000,
data = dat2,chains=1,
pars=c("sigma","M","Sd_d","pi","alpha"))
triple.out
install.packages("loo")
library(loo)
loo(triple.out)
triple.lik <- extract_log_lik(triple.out, parameter_name = "log_lik")
triple.lik <- extract_log_lik(triple.out)
triple.mod <-"
data{
int N; // sample size
int t;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[2] FS[N]; // factor scores, matrix of order [N,D]
cholesky_factor_cov[2] Rho; // correlation matrix between factors
real sigma; // variance for each variable
vector[2] M;
vector[2] alpha;
real pi;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
matrix[2,2] Sd_d;
Sd_d = multiply_lower_tri_self_transpose(Rho);
for (i in 1:N){
mu[i,1] = FS[i,1];
d[i,1] = pi*mu[i,1] + 1*FS[i,2];
mu[i,2] = d[i,1]+mu[i,1];
for (tt in 3:t){
d[i,tt-1] = pi*mu[i,tt-1] + alpha[tt-2]*FS[i,2];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
pi ~ normal(0,.5);
alpha ~ normal(2,3);
for (i in 1:N){
FS[i] ~ multi_normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
triple.out=stan(model_code=triple.mod,iter=5000,warmup=2000,
data = dat2,chains=1,
pars=c("sigma","M","Sd_d","pi","alpha"))
triple.lik <- extract_log_lik(triple.out)
triple.out=stan(model_code=triple.mod,iter=5000,warmup=2000,
data = dat2,chains=1,
pars=c("sigma","M","Sd_d","pi","alpha","log_lik"))
triple.lik <- extract_log_lik(triple.out)
loo(triple.out)
loo(triple.lik)
library(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
library(rstanmulticore)
library(loo)
wisc <- read.table("C:/Users/RJacobucci/Documents/GitHub/EDM_Labs/2015/wisc4vpe.dat")
wisc <- read.table("C:/Users/jacobucc/Documents/GitHub/EDM_Labs/2015/wisc4vpe.dat")
names(wisc)<- c("V1","V2","V4","V6","P1","P2","P4", "P6", "Moeducat")
X <- wisc[,c("V1","V2","V4","V6")]
data = list()
#data$alpha <- c(1,1,2,2)
X = as.matrix(X)
N <- nrow(X)
dat2 <- list(
N = N,
X = X,
t = 4)
# -----------------------------
#### No Change ###########
# ----------------------------
noChange.mod <-"
data{
int N; // sample size
int t;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[1] FS[N]; // factor scores, matrix of order [N,D]
real sigma; // variance for each variable
real Sd_d;
real M;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
for (i in 1:N){
mu[i,1] = FS[i,1];
for (tt in 2:t){
d[i,tt-1] = 0;
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
for (i in 1:N){
FS[i] ~ normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
noChange.out=stan(model_code=noChange.mod,iter=5000,warmup=2000,
data = dat2,chains=1,
pars=c("sigma","M","Sd_d","log_lik"))
noChange.out
noChange.lik <- extract_log_lik(noChange.out)
loo(noChange.lik)
# ----------------------------------
# Proportional Change
# ---------------------------------
proportional.mod <-"
data{
int N; // sample size
int t;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[1] FS[N]; // factor scores, matrix of order [N,D]
real sigma; // variance for each variable
real Sd_d;
real M;
real pi;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
for (i in 1:N){
mu[i,1] = FS[i,1];
for (tt in 2:t){
d[i,tt-1] = pi*mu[i,tt-1];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
pi ~ normal(0,1);
for (i in 1:N){
FS[i] ~ normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
proportional.out=stan(model_code=proportional.mod,iter=5000,warmup=2000,
data = dat2,chains=1,
pars=c("sigma","M","Sd_d","pi","log_lik"))
proportional.out
proportional.lik <- extract_log_lik(proportional.out)
loo(proportional.lik)
# -------------------------------------
# Constant Change
# -------------------------------------
dat3 <- list(
N = N,
X = X,
t = 4,
alpha=c(1,1,2,2))
constant.mod <-"
data{
int N; // sample size
int t;
vector[t] alpha;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[2] FS[N]; // factor scores, matrix of order [N,D]
cholesky_factor_cov[2] Rho; // correlation matrix between factors
real sigma; // variance for each variable
vector[2] M;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
matrix[2,2] Sd_d;
Sd_d = multiply_lower_tri_self_transpose(Rho);
for (i in 1:N){
mu[i,1] = FS[i,1];
for (tt in 2:t){
d[i,tt-1] = alpha[tt]*FS[i,2];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
for (i in 1:N){
FS[i] ~ multi_normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
constant.out=stan(model_code=constant.mod,iter=5000,warmup=2000,
data = dat3,chains=1,
pars=c("sigma","M","Sd_d","log_lik"))
constant.out
constant.lik <- extract_log_lik(constant.out)
loo(constant.lik)
# -----------------------------------------
# Dual Change
# -----------------------------------------
dual.mod <-"
data{
int N; // sample size
int t;
vector[t] alpha;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[2] FS[N]; // factor scores, matrix of order [N,D]
cholesky_factor_cov[2] Rho; // correlation matrix between factors
real sigma; // variance for each variable
vector[2] M;
real pi;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
matrix[2,2] Sd_d;
Sd_d = multiply_lower_tri_self_transpose(Rho);
for (i in 1:N){
mu[i,1] = FS[i,1];
for (tt in 2:t){
d[i,tt-1] = pi*mu[i,tt-1] + alpha[tt]*FS[i,2];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
pi ~ normal(0,.5);
for (i in 1:N){
FS[i] ~ multi_normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
dual.out=stan(model_code=dual.mod,iter=5000,warmup=2000,
data = dat3,chains=1,
pars=c("sigma","M","Sd_d","pi","log_lik"))
dual.out
dual.lik <- extract_log_lik(dual.out)
loo(dual.lik)
# --------------------------------------------------
# Changes to Changes
# --------------------------------------------------
changes.mod <-"
data{
int N; // sample size
int t;
vector[t] alpha;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[2] FS[N]; // factor scores, matrix of order [N,D]
cholesky_factor_cov[2] Rho; // correlation matrix between factors
real sigma; // variance for each variable
vector[2] M;
real pi;
real phi;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
matrix[2,2] Sd_d;
Sd_d = multiply_lower_tri_self_transpose(Rho);
for (i in 1:N){
mu[i,1] = FS[i,1];
d[i,1] = pi*mu[i,1] + alpha[2]*FS[i,2];
mu[i,2] = d[i,1]+mu[i,1];
for (tt in 3:t){
d[i,tt-1] = pi*mu[i,tt-1] + alpha[tt]*FS[i,2] + phi*d[i,tt-2];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
pi ~ normal(0,1);
phi ~ normal(0,1);
for (i in 1:N){
FS[i] ~ multi_normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
changes.out=stan(model_code=changes.mod,iter=5000,warmup=2000,
data = dat3,chains=1,
pars=c("sigma","M","Sd_d","pi","phi","log_lik"))
changes.out
changes.lik <- extract_log_lik(changes.out)
loo(changes.lik)
# ---------------------------------
# Triple Change
# ---------------------------------
triple.mod <-"
data{
int N; // sample size
int t;
vector[t] X[N]; // data matrix of order [N,P]
}
parameters{
vector[2] FS[N]; // factor scores, matrix of order [N,D]
cholesky_factor_cov[2] Rho; // correlation matrix between factors
real sigma; // variance for each variable
vector[2] M;
vector[2] alpha;
real pi;
}
transformed parameters{
vector[t] mu[N];
vector[t-1] d[N];
matrix[2,2] Sd_d;
Sd_d = multiply_lower_tri_self_transpose(Rho);
for (i in 1:N){
mu[i,1] = FS[i,1];
d[i,1] = pi*mu[i,1] + 1*FS[i,2];
mu[i,2] = d[i,1]+mu[i,1];
for (tt in 3:t){
d[i,tt-1] = pi*mu[i,tt-1] + alpha[tt-2]*FS[i,2];
mu[i,tt] = d[i,tt-1]+mu[i,tt-1];
}
}
}
model{
pi ~ normal(0,.5);
alpha ~ normal(2,3);
for (i in 1:N){
FS[i] ~ multi_normal(M, Sd_d);
X[i,1] ~ normal(mu[i,1],pow(sigma,0.5));
for (tt in 2:t){
X[i,tt] ~ normal(mu[i,tt], pow(sigma,0.5));
}
}
}
generated quantities {
vector[N] log_lik;
for (n in 1:N){
log_lik[n] = normal_lpdf(X[n,]| mu[n], sigma);
}
}
"
triple.out=stan(model_code=triple.mod,iter=5000,warmup=2000,
data = dat2,chains=1,
pars=c("sigma","M","Sd_d","pi","alpha","log_lik"))
triple.out
triple.lik <- extract_log_lik(triple.out)
loo(triple.lik)
save.image("C:/Users/RJacobucci/Documents/GitHub/LCS_alternate/stanLCSmods.RData")
