# check for groups
#model@pta$ngroups
nvar = model@pta$nvar[[1]][1]
A_init <- matrix(0, nrow = nvar + nfac2, ncol = nvar + nfac2)
#unique(nfac.hold1$lhs)
name <- unique(pars$lhs)
name.vars <- model@pta$vnames$ov[[1]]
name.factors <- model@pta$vnames$lv[[1]]
if(identical(name.factors, character(0))){
name.factors2=NA
}else{
name.factors2 = name.factors
}
if(length(name.factors)!=0){
if(mean==TRUE){
colnames(A_init) <- c(name.vars,"1",name.factors)
rownames(A_init) <- c(name.vars,"1",name.factors)
}else{
colnames(A_init) <- c(name.vars,name.factors)
rownames(A_init) <- c(name.vars,name.factors)
}
}else{
if(mean==TRUE){
colnames(A_init) <- c(name.vars,"1")
rownames(A_init) <- c(name.vars,"1")
}else{
colnames(A_init) <- c(name.vars)
rownames(A_init) <- c(name.vars)
}
}
A <- A_init
A.parT = parT[parT$op == "=~" | parT$op == "~1" | parT$op == "~",]
A.pars = pars[parT$op == "=~" | parT$op == "~1" | parT$op == "~",]
A.parFree <- A.parT[A.parT$free > 0,]
uniq <- unique(A.parFree[,"label"])
uniq2 <- uniq[table(A.parFree[,"label"]) == 1]
pars.align.A = matrix(NA,length(A.parT$free),2)
A.parFree2 = A.parFree
if(length(uniq2)>0){
for(i in 1:length(uniq2)){
A.parFree[A.parFree[,"label"] == uniq2[i],"label"] <- ""
}
}
# any equality?
if(any(duplicated(A.parFree$label[A.parFree$label != ""]) == T)){
labels = unique(A.parFree$label[A.parFree$label != ""])
for(i in 1:length(labels)){
equals = A.parFree$free[A.parFree$label == labels[i]]
min.equal = min(equals)
max.equal = max(equals)
A.parFree$free[A.parFree$label == labels[i]] <- min.equal
#  dec = max.equal - min.equal
# A.parFree$free[A.parFree$label == labels[i]] <- A.parFree$free[A.parFree$label == labels[i]] - dec
}
#equals = A.parFree$free[A.parFree$label == labels]
}
A.parFree[,"free"] <- rank(A.parFree[,"free"],ties.method="min")
A.parFree2 <- A.parFree
A.parFree[,"free"] <- rank(A.parFree[,"free"],ties.method="min")
A.parFree2 <- A.parFree
loadings <- NULL
regressions <- NULL
if(nrow(A.parFree2) > 0){
for(i in 1:nrow(A.parFree2)){
if(A.parFree2$op[i] == "=~"){
colNum <- which(A.parFree2$lhs[i] == colnames(A))
rowNum <- which(A.parFree2$rhs[i] == rownames(A))
A[rowNum,colNum] = A.parFree2[i,"free"]
loadings = c(loadings,A.parFree2[i,"free"])
}else if(A.parFree2$op[i] == "~1"){
A[which(rownames(A)==A.parFree2$lhs[i]),which(colnames(A) == "1")] = A.parFree2[i,"free"]
}else if(A.parFree2$op[i] == "~"){
colNum <- which(A.parFree2$rhs[i] == colnames(A))
rowNum <- which(A.parFree2$lhs[i] == rownames(A))
A[rowNum,colNum] = A.parFree2[i,"free"]
regressions = c(regressions,A.parFree2[i,"free"])
}
pars.align.A[i,] = c(i,A.parFree2[i,"label"])
}
}else{
A = A
}
pars.align.A
A.parFree2
A.parT
A.parFree
library(regsem)
cv.result <- cv_regsem(model=result, n.lambda = 15,jump = .08,pars_pen = c("a","b"))
cv.result
reg.out <- cv_regsem(lav.out,n.lambda=50,type="lasso",jump=0.03,
pars_pen=c("c1","c2","c3","c4","c5","c6","c7","c8"))
reg.out
library(regsem)
library(regsem)
library(regsem)
?legend
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(foreign)
dat <- read.spss("C:/Users/rjacobuc/Desktop/EFA_NSSIDisclose.sav",to.data.frame=T,value.labels=F)
head(dat)
dat.mat <- data.matrix(dat)
head(dat.mat)
library(regsem)
lav.mod <- "
f =~ NA*SISRQ2 + SISRQ3 + SISRQ4 + SISRQ10 + SISRQ11 + SISRQ12 + SISRQ13 + SISRQ17 + SISRQ18 +
SISRQ19 + SISRQ20 + SISRQ21 + SISRQ25 + SISRQ26 + SISRQ27 + SISRQ28 + SISRQ29 + SISRQ31 + SISRQ32 +
SISRQ33 + SISRQ34 + SISRQ35 + SISRQ36 + SISRQ41 + SISRQ42 + SISRQ43 + SISRQ44
f ~~ 1*f
"
lav.mod2 = paste(lav.mod,list,sep="\n")
#lav.out <- cfa(lav.mod2,dat.mat)
summary(lav.out,fit=T)
extractMatrices(lav.out)["S"]
#cv.out <- cv_regsem(lav.out,pars_pen=28:378,n.lambda=20,jump=.05,type="ridge",mult.start=T)
plot(cv.out)
cv.out$final_pars
cv.out$fits
lav.mod <- "
f =~ NA*SISRQ2 + SISRQ3 + SISRQ4 + SISRQ10 + SISRQ11 + SISRQ12 + SISRQ13 + SISRQ17 + SISRQ18 +
SISRQ19 + SISRQ20 + SISRQ21 + SISRQ25 + SISRQ26 + SISRQ27 + SISRQ28 + SISRQ29 + SISRQ31 + SISRQ32 +
SISRQ33 + SISRQ34 + SISRQ35 + SISRQ36 + SISRQ41 + SISRQ42 + SISRQ43 + SISRQ44
f ~~ 1*f
"
lav.out <- cfa(lav.mod,dat.mat)
extractMatrices(lav.out)["A"]
sel = 6:10
reg.out1 <- regsem(lav.out,pars_pen=sel,lambda=.5)
summary(reg.out1)
summary(reg.out1)$estimates[sel]
cv.out <- cv_regsem(lav.out,n.lambda=20,jump=.05,pars_pen="loadings",fit.ret2="boot",metric="chisq",fit.ret="chisq")
cv.out
?fit_indices
library(regsem)
cv.out <- cv_regsem(lav.out,n.lambda=20,jump=.05,pars_pen="loadings",fit.ret2="boot",metric="chisq",fit.ret="chisq")
library(regsem)
library(regsem)
cv.out <- cv_regsem(lav.out,n.lambda=20,jump=.05,pars_pen="loadings",fit.ret2="boot",metric="chisq",fit.ret="chisq")
plot(cv.out)
cv.out
plot(cv.out,show.minimum="chisq")
?cv_regsem
?cv_regsem
library(regsem)
?cv_regsem
HS <- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod <- '
f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
'
outt = cfa(mod, HS)
# increase to > 25
cv.out = cv_regsem(outt,type="lasso", pars_pen=c(1:2,6:8),
n.lambda=5,jump=0.01,fit.ret="cv")
# increase to > 25
cv.out = cv_regsem(outt,type="lasso", pars_pen=c(1:2,6:8),
n.lambda=5,jump=0.01,fit.ret="boot")
# increase to > 25
cv.out = cv_regsem(outt,type="lasso", pars_pen=c(1:2,6:8),
n.lambda=5,jump=0.01,fit.ret2="cv")
?fit_indices
library(regsem)
# increase to > 25
cv.out = cv_regsem(outt,type="lasso", pars_pen=c(1:2,6:8),
n.lambda=5,jump=0.01,fit.ret2="cv")
cv.out
# increase to > 25
cv.out = cv_regsem(outt,type="lasso", pars_pen=c(1:2,6:8),
n.lambda=5,jump=0.01,fit.ret2="train")
cv.out
library(regsem)
HS <- HolzingerSwineford1939
colnames(HS)
outt = cfa(mod, HS)
summary(outt)
mod <- '
f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
'
outt = cfa(mod, HS)
summary(outt)
mod2 <- '
f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
fs1 =~ x1 + x2 + x3
fs2 =~ x4 + x5 + x6
fs3 =~ x7 + x8 + x9
'
outt2 = cfa(mod2, HS,orthogonal=T)  # orthogonal makes all latent factors uncorrelated
?cfa
mod2 <- '
f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
fs1 =~ x1 + x2 + x3
fs2 =~ x4 + x5 + x6
fs3 =~ x7 + x8 + x9
f ~~ 0*fs1 # make all uncorrelated
f ~~ 0*fs2
f ~~ 0*fs3
fs1 ~~0*fs2
fs1 ~~ 0*fs3
fs2 ~~ 0*fs3
'
outt2 = cfa(mod2, HS)
summary(outt)
summary(outt2)
mod2 <- '
f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
fs1 =~ NA*x1 + x2 + x3 # free up first factor loadings
fs2 =~ NA*x4 + x5 + x6
fs3 =~ NA*x7 + x8 + x9
f ~~ 0*fs1 # make all uncorrelated
f ~~ 0*fs2
f ~~ 0*fs3
fs1 ~~0*fs2
fs1 ~~ 0*fs3
fs2 ~~ 0*fs3
fs1 ~~1*fs1
fs2 ~~ 1*fs2
fs3 ~~ 1*fs3
'
outt2 = cfa(mod2, HS)
summary(outt2)
mod2 <- '
f =~ NA*x1 + x2 + x3 + 1*x4 + x5 + x6 + x7 + x8 + x9
fs1 =~ NA*x1 + x2 + x3 # free up first factor loadings
fs2 =~ NA*x4 + x5 + x6
fs3 =~ NA*x7 + x8 + x9
f ~~ 0*fs1 # make all uncorrelated
f ~~ 0*fs2
f ~~ 0*fs3
fs1 ~~0*fs2
fs1 ~~ 0*fs3
fs2 ~~ 0*fs3
fs1 ~~1*fs1
fs2 ~~ 1*fs2
fs3 ~~ 1*fs3
'
outt2 = cfa(mod2, HS)
summary(outt2)
mod2 <- '
f =~ x4 + x5 + x6 + x7 + x8 + x9
fs2 =~ NA*x4 + x5 + x6
fs3 =~ NA*x7 + x8 + x9
f ~~ 0*fs2
f ~~ 0*fs3
fs2 ~~ 0*fs3
fs2 ~~ 1*fs2
fs3 ~~ 1*fs3
'
outt2 = cfa(mod2, HS)
summary(outt2)
mod2 <- '
f =~ NA*x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
fs1 =~ NA*x1 + x2 + x3 # free up first factor loadings
fs2 =~ NA*x4 + x5 + x6
fs3 =~ NA*x7 + x8 + x9
f ~~ 0*fs1 # make all uncorrelated
f ~~ 0*fs2
f ~~ 0*fs3
fs1 ~~0*fs2
fs1 ~~ 0*fs3
fs2 ~~ 0*fs3
f ~~ 1*f
fs1 ~~1*fs1
fs2 ~~ 1*fs2
fs3 ~~ 1*fs3
'
outt2 = cfa(mod2, HS)
summary(outt2)
lavPredict(mod2)
lavPredict(outt2)
fscore = lavPredict(outt2)["f"]
hist(fscore)
hist(fscore,15)
fscore
fscore = lavPredict(outt2)["f"]
fscore
fscore = lavPredict(outt2)[,"f"]
hist(fscore,15)
library(regsem)
initialModel = function(nFactors, variables){
factors = paste("f",1:nFactors,sep = "") #prepare factor labels
loadings = matrix(paste("lambda_",expand.grid(1:length(variables), 1:nFactors)[,2],"_", expand.grid(1:length(variables), 1:nFactors)[,1], sep = "")
,length(variables),nFactors) # prepare loading matrices
# don't fix first loading to 1
loadings[1,] = NA
#set restricions
# sum of loadings > 0 per factor (to prefer positive loadings)
# Note the factors can be sign-inverted any time, it is just for convenience (e.g., plotting)
# that we prefer positive loadings, this procedure imitates the behaviour of Mplus
loadingConstraints = paste(apply(loadings[-1,], MARGIN = 2, function(x){
paste(paste(x,collapse = " + "), " > 0", collapse = "")
}), collapse = "\n")
loadings = apply(loadings,MARGIN = 2,FUN = function(x){paste(x,variables,sep = "*")})
# These lines are only an automatized way to write the model definitions
# for a large number of variables.
# In order to make this step more transparent, the model definition
# is saved in a document called "model.txt". We recommend you refer to this file
# if you want to see the model specification in detail.
measurementModels = sapply(1:nFactors,FUN = function(x){paste(factors[x],"=~",paste(loadings[,x],collapse = "+"),collapse = "\n")})
factorCombinations = expand.grid(factors,factors)
test = expand.grid(1:nFactors,1:nFactors) #remove redundant covariances
factorCombinations = factorCombinations[test[,1] <= test[,2],]
factorCovariances = sapply(1:dim(factorCombinations)[1], function(x){ifelse(factorCombinations[x,1] == factorCombinations[x,2],paste(factorCombinations[x,1],"~~1*",factorCombinations[x,2],sep = ""),paste(factorCombinations[x,1],"~~NA*",factorCombinations[x,2],sep = ""))})
model = c(measurementModels,loadingConstraints, factorCovariances)
writeLines(model, "model.txt")
return(model)
}
library(regsem)
HS <- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod = initialModel(3, colnames(HS))
mod
cat(mod)
mod2 = cat(mod)
mod2 = paste0(mod)
mod2
mod2 = unlist(mod)
mod
mod2
mod2 = paste0(mod)
mod2
mod2 = paste(mod)
mod2
str(mod2)
str(mod)
?cat
paste(mod,sep="")
out = cfa(mod,HS)
mod = initialModel(2, colnames(HS))
out = cfa(mod,HS)
out
summary(out)
extractMatrices(out)
reg.out <- cv_regsem(out)
reg.out <- cv_regsem(out,pars="loadings")
reg.out
reg.out$parameters[2,]
extractMatrices(out)
mod = initialModel(3, colnames(HS))
out = cfa(mod,HS)
extractMatrices(out)
reg.out <- cv_regsem(out,pars="loadings")
reg.out
semFit = sem(mod, data = HS, int.ov.free = FALSE, int.lv.free = FALSE,
std.lv = TRUE, std.ov = TRUE, auto.fix.single = FALSE, se = "none")
reg.out2 = cv_regsem(model = semFit, pars_pen = "loadings",
mult.start = TRUE, multi.iter = 10,
n.lambda = 100, type = "lasso", jump = 10^-5, lambda.start = 0.001)
reg.out2
reg.out2 = cv_regsem(model = semFit, pars_pen = "loadings",
# mult.start = TRUE, multi.iter = 10,
n.lambda = 100, type = "lasso", jump = 10^-5, lambda.start = 0.001)
10^-5
.001
reg.out2 = cv_regsem(model = semFit, pars_pen = "loadings",
# mult.start = TRUE, multi.iter = 10,
n.lambda = 40, type = "lasso", jump = .001, lambda.start = 0.001)
reg.out2
10^-5 * 100
reg.out2 = cv_regsem(model = semFit, pars_pen = "loadings",
mult.start = TRUE, multi.iter = 10,
n.lambda = 100, type = "lasso", jump = 10^-5, lambda.start = 0.001)
reg.out2
plot(reg.out2)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
HS <- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod = initialModel(5, colnames(HS))
semFit = sem(mod, data = HS, int.ov.free = FALSE, int.lv.free = FALSE,
std.lv = TRUE, std.ov = TRUE, auto.fix.single = FALSE, se = "none")
# note it requires smaller penalties than other applications
reg.out2 = cv_regsem(model = semFit, pars_pen = "loadings",
mult.start = TRUE, multi.iter = 10,
n.lambda = 100, type = "lasso", jump = 10^-5, lambda.start = 0.001)
reg.out2
sim.mod <- "
f1 =~ 1*x1 + 1*x2 + 1*x3
f2 =~ 1*x4 + 1*x5 + 1*x6
f3 =~ 1*x7 + 1*x8 + 1*x9
"
dat <- simulateData(sim.mod)
mod2 = initialModel(5, colnames(dat))
semFit2 = sem(mod2, data = dat, int.ov.free = FALSE, int.lv.free = FALSE,
std.lv = TRUE, std.ov = TRUE, auto.fix.single = FALSE, se = "none")
semFit2
# note it requires smaller penalties than other applications
reg.out3 = cv_regsem(model = semFit2, pars_pen = "loadings",
mult.start = TRUE, multi.iter = 10,
n.lambda = 100, type = "lasso", jump = 10^-5, lambda.start = 0.001)
reg.out3
10^-3
# note it requires smaller penalties than other applications
reg.out3 = cv_regsem(model = semFit2, pars_pen = "loadings",
mult.start = TRUE, multi.iter = 10,
n.lambda = 40, type = "lasso", jump = 10^-3, lambda.start = 0.001)
reg.out3
reg.out3$parameters[40,]
reg.out3$parameters[35,]
reg.out3$parameters[30,]
reg.out3$parameters[25,]
reg.out3$parameters[20,]
reg.out3$parameters[15,]
reg.out3$parameters[10,]
summary(semFit2)
# note it requires smaller penalties than other applications
reg.out3 = cv_regsem(model = semFit2, pars_pen = "loadings",
mult.start = TRUE, multi.iter = 10,
n.lambda = 40, type = "scad", jump = 10^-5, lambda.start = 0.001)
# note it requires smaller penalties than other applications
reg.out3 = cv_regsem(model = semFit2, pars_pen = "loadings",
mult.start = TRUE, multi.iter = 10,optMethod="coord_desc",
n.lambda = 20, type = "scad", jump = 10^-5, lambda.start = 0.001)
reg.out3
# note it requires smaller penalties than other applications
reg.out3 = cv_regsem(model = semFit2, pars_pen = "loadings",
mult.start = TRUE, multi.iter = 10,optMethod="coord_desc",
n.lambda = 20, type = "scad", jump = 10^-1, lambda.start = 0.001)
reg.out3
# note it requires smaller penalties than other applications
reg.out3 = cv_regsem(model = semFit2, pars_pen = "loadings",
mult.start = TRUE, multi.iter = 10,optMethod="coord_desc",
n.lambda = 20, type = "scad", jump = .05, lambda.start = 0.001)
reg.out3
# note it requires smaller penalties than other applications
reg.out3 = cv_regsem(model = semFit2, pars_pen = "loadings",
mult.start = TRUE, multi.iter = 10,optMethod="coord_desc",
n.lambda = 20, type = "scad", jump = .5, lambda.start = 0.001)
reg.out3
# note it requires smaller penalties than other applications
reg.out3 = cv_regsem(model = semFit2, pars_pen = "loadings",
mult.start = TRUE, multi.iter = 10,optMethod="coord_desc",
n.lambda = 20, type = "mcp", jump = .05, lambda.start = 0.001)
reg.out3
# note it requires smaller penalties than other applications
reg.out3 = cv_regsem(model = semFit2, pars_pen = "loadings",
mult.start = TRUE, multi.iter = 10,
n.lambda = 20, type = "lasso", jump = 10^-5, lambda.start = 0)
reg.out3
library(regsem)
library(regsem)
install.packages("roxygen2")
library(regsem)
library(regsem)
runif(0.5,1)
runif(1,0.05,1)
?runif
library(regsem)
library(regsem)
install.packages("roxygen2")
library(regsem)
?cv_regsem
library(regsem)
library(regsem)
vignette("overview",package="regsem")
# put variables on same scale for regsem
HS <- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod <- '
f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
'
outt = cfa(mod, HS)
# increase to > 25
cv.out = cv_regsem(outt,type="rlasso", pars_pen=c(1:2,6:8),
n.lambda=20,jump=0.01)
library(regsem)
vignette("overview",package="regsem")
# put variables on same scale for regsem
HS <- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod <- '
f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
'
outt = cfa(mod, HS)
# increase to > 25
cv.out = cv_regsem(outt,type="rlasso", pars_pen=c(1:2,6:8),
n.lambda=20,jump=0.01)
library(regsem)
vignette("overview",package="regsem")
# put variables on same scale for regsem
HS <- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod <- '
f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
'
outt = cfa(mod, HS)
# increase to > 25
cv.out = cv_regsem(outt,type="rlasso", pars_pen=c(1:2,6:8),
n.lambda=20,jump=0.01)
# increase to > 25
cv.out = cv_regsem(outt,type="rlasso", pars_pen=c(1:2,6:8),
n.lambda=5,jump=0.01)
library(regsem)
# increase to > 25
cv.out = cv_regsem(outt,type="rlasso", pars_pen=c(1:2,6:8),
n.lambda=5,jump=0.01)
library(regsem)
# increase to > 25
cv.out = cv_regsem(outt,type="rlasso", pars_pen=c(1:2,6:8),
n.lambda=5,jump=0.01)
cv.out
library(regsem)
# increase to > 25
cv.out = cv_regsem(outt,type="rlasso", pars_pen=c(1:2,6:8),
n.lambda=5,jump=0.01)
cv.out
# increase to > 25
cv.out = cv_regsem(outt,type="rlasso", pars_pen=c(1:2,6:8),
n.lambda=20,jump=0.01)
cv.out
library(regsem)
# increase to > 25
cv.out = cv_regsem(outt,type="rlasso", pars_pen=c(1:2,6:8),
n.lambda=20,jump=0.01)
cv.out
