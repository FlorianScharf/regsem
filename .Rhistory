library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
(samps[i]/nobs)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
model@SampleStats@missing[[1]]
model@Data@nobs
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
library(regsem)
wisc <- read.table("/Users/RJacobucci/Documents/Github/random_code/wisc4vpe.dat")
names(wisc)<- c("V1","V2","V4","V6","P1","P2","P4", "P6", "Moeducat")
library(lavaan)
library(semPlot)
model <- ' i =~ 1*V1 + 1*V2 + 1*V4 + 1*V6
s =~ 1*V1 + 2*V2 + 4*V4 + 6*V6
#residuals equal
V1 ~~ resid*V1; V2 ~~ resid*V2; V4 ~~ resid*V4; V6 ~~ resid*V6;'
fit <- growth(model, data=wisc)
summary(fit)
fitMeasures(fit)
model2 <- ' i =~ 1*V1 + 1*V2 + 1*V4 + 1*V6
s =~ 0*V1 + l1*V2 + l2*V4 + 5*V6
#residuals equal
V1 ~~ resid*V1; V2 ~~ resid*V2; V4 ~~ resid*V4; V6 ~~ resid*V6;'
fit2 <- growth(model2, data=wisc)
summary(fit2)
lds_1 <- "
#latent variables
lV1 =~ 1*V1
lV2 =~ 1*V2
lV4 =~ 1*V4
lV6 =~ 1*V6
#autoregressions
lV2 ~ 1*lV1; lV4 ~ 1*lV2; lV6 ~ 1*lV4
#change - delta; d
dV1 =~ 1*lV2; dV2 =~ 1*lV4; dV3 =~ 1*lV6
#intercept and slope
inV =~ 1*lV1;
#slope =~ alpha*dV1 + alpha*dV2 + alpha*dV3
# match lgm
slope =~ 1*dV1 + 2*dV2 + 2*dV3
#slope =~ 1.17*dV1 + alpha1*dV2 + alpha2*dV3
#manifest means @0
V1 ~ 0*1; V2 ~0*1; V4 ~ 0*1; V6 ~ 0*1
#slope and intercept means
slope ~ 1;
inV ~ 1;
#Latent variances and covariance
slope ~~ slope;
inV ~~ inV;
slope ~~ inV;
#means and vars @0
lV1 ~ 0*1; lV2 ~0*1; lV4 ~ 0*1; lV6 ~ 0*1
dV1 ~ 0*1; dV2 ~0*1; dV3 ~ 0*1
lV1 ~~ 0*lV1; lV2 ~~ 0*lV2; lV4 ~~ 0*lV4; lV6 ~~ 0*lV6
dV1 ~~ 0*dV1; dV2 ~~ 0*dV2; dV3 ~~ 0*dV3
#auVo-proportions
dV1 ~ beta*lV1; dV2 ~ beta*lV2; dV3 ~ beta*lV4;
# changes to changes parameter
dV2 ~ beta2*dV1; dV3 ~ beta2*dV2;
#residuals equal
V1 ~~ resid*V1; V2 ~~ resid*V2; V4 ~~ resid*V4; V6 ~~ resid*V6;
"
fit.lds <- lavaan(lds_1, data=wisc)
summary(fit.lds)
library(regsem)
extractMatrices(fit.lds) # not dealing with equality
# took out equality constraints message in regsem()
starts <- c(-5,19,.5,.5,2,18,-5,10)
out <- regsem(fit.lds,lambda=0,type="lasso",optMethod="nlminb",gradFun="none",Start=starts)
summary(out)
model <- ' i =~ 1*V1 + 1*V2 + 1*V4 + 1*V6
s =~ 1*V1 + 2*V2 + 4*V4 + 6*V6
#residuals equal
V1 ~~ resid*V1; V2 ~~ resid*V2; V4 ~~ resid*V4; V6 ~~ resid*V6;'
fit <- growth(model, data=wisc)
summary(fit)
out <- regsem(fit,lambda=0,type="none",optMethod="nlminb",gradFun="none")
summary(out)
summary(fit)
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram")
summary(out)
out <- regsem(fit,lambda=0,type="none",optMethod="nlminb",gradFun="ram")
summary(out)
fitMeasures(fit)
out <- regsem(fit,lambda=0,type="none",optMethod="nlminb",gradFun="ram")
summary(out)
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram")
summary(out)
out <- multi_optim(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram")
summary(out)
verbose=FALSE,warm.start=FALSE,Start2=NULL,
library(regsem)
out <- multi_optim(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram")
summary(out)
library(regsem)
out <- multi_optim(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram")
library(regsem)
out <- multi_optim(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram")
library(regsem)
extractMatrices(fit)
parTable(fit)
extractMatrices(fit)
out <- multi_optim(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram")
out <- multi_optim(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",tol=1e-3)
?multi_optim
library(regsem)
out <- multi_optim(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",tol=1e-3)
summary(out)
model <- ' i =~ 1*V1 + 1*V2 + 1*V4 + 1*V6
s =~ 1*V1 + l1*V2 + l2*V4 + 6*V6
#residuals equal
V1 ~~ resid*V1; V2 ~~ resid*V2; V4 ~~ resid*V4; V6 ~~ resid*V6;'
fit <- growth(model, data=wisc)
summary(fit)
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram")
out <- multi_optim(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",tol=1e-3)
summary(out)
out <- regsem(fit,lambda=0,type="none",optMethod="nlminb",gradFun="ram")
summary(out)
out <- multi_optim(fit,lambda=0,type="none",optMethod="nlminb",gradFun="ram",tol=1e-3)
summary(out)
out <- multi_optim(fit,lambda=0,type="none",optMethod="nlminb",gradFun="ram",tol=1e-3)
summary(out)
summary(fit)
out <- regsem(fit,lambda=0,type="none",optMethod="nlminb",gradFun="ram")
summary(out)
summary(fit)
out <- multi_optim(fit,lambda=0,type="none",optMethod="nlminb",gradFun="none",tol=1e-3)
summary(out)
out <- multi_optim(fit,lambda=0,type="none",optMethod="nlminb",gradFun="none",tol=1e-6)
summary(out)
?nlminb
out <- regsem(fit,lambda=0,type="none",optMethod="nlminb",gradFun="none")
summary(out)
extractMatrices(fit)
model <- ' i =~ 1*V1 + 1*V2 + 1*V4 + 1*V6
s =~ 0*V1 + 1*V2 + 3*V4 + 5*V6
#residuals equal
V1 ~~ resid*V1; V2 ~~ resid*V2; V4 ~~ resid*V4; V6 ~~ resid*V6;'
fit <- growth(model, data=wisc)
out <- regsem(fit,lambda=0,type="none",optMethod="nlminb",gradFun="none")
summary(out)
fitMeasures(fit)
summary(fit)
extractMeasures(fit)
extractMatrices(fit)
out <- regsem(fit,lambda=0,type="none",optMethod="nlminb",gradFun="ram")
summary(out)
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram")
summary(out)
library(regsem)
library(regsem)
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",max.iter=20)
library(regsem)
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",max.iter=20)
library(regsem)
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",max.iter=20,Start=extractMatrices(fit)$parameters)
summary(out)
fitMeasures(fit)
extractMatrices(fit)$parameters
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",max.iter=20,Start=rep(.5,6))
library(regsem)
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",max.iter=20,Start=rep(.5,6))
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",max.iter=50,Start=rep(.5,6))
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",max.iter=100,Start=rep(.5,6))
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",max.iter=200,Start=rep(.5,6))
summary(out)
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",max.iter=300,Start=rep(.5,6))
summary(out)
out <- regsem(fit,lambda=0,type="none",optMethod="coord_desc",gradFun="ram",max.iter=300)
summary(out)
library(regsem)
out <- regsem(fit.lds,lambda=0,type="lasso",optMethod="coord_desc",gradFun="ram")
#system.time(fit1 <- multi_optim(fit.lds,lambda=0,type="none",warm.start=FALSE,gradFun="ram",optMethod="coord_desc"))
summary(out)
out <- regsem(fit.lds,lambda=0,type="lasso",optMethod="coord_desc",gradFun="ram",Start=starts)
library(lavaan)
HS <- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod <- '
f =~ NA*x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
f~~1*f
'
outt = cfa(mod,HS,meanstructure=FALSE)
system.time(cfa(mod,HS,meanstructure=TRUE))
summary(outt)
system.time(fit1 <- regsem(outt,lambda=0,type="none",optMethod="coord_desc",
gradFun="ram",block=TRUE))
summary(fit1);fit1$out$iterations
## Simulating time series data from ------------------------
## Phi (lag) and A (contemp) matrices ----------------------
ts.generate <- function (A,Phi,t) {
repeat {
nvar  <- ncol(A)
noise <- matrix(rnorm(nvar*250,0,1),nvar)
I     <- diag(nvar)
time  <- matrix(0,nrow=nvar,ncol=251)
time1 <- matrix(0,nrow=nvar,ncol=250)
for (i in 1:250){
time1[,i]  <- solve(I-A)%*%(Phi%*%time[,i] + noise[,i])
time[,i+1] <- time1[,i]
}
time1  <- time1[,(50:(50+t))]
series <- t(time1)
if (abs(max(series)) < 20 & abs(min(series)) > .01 & abs(min(series)) < 20) break
}
return(series)
}
A <- matrix(
c(0,  0, .5,
.5,  0,  0,
0,  0,  0), nrow = 3, ncol = 3, byrow = TRUE)
Phi <- matrix(
c(.5,  0,  0,
0, .5,  0,
0, .5, .5), nrow = 3, ncol = 3, byrow = TRUE)
data     <- ts.generate(A, Phi, 200)
first    <- data[1:(nrow(data)-1), ]
second   <- data[2:nrow(data), ]
data.lag <- data.frame(first, second)
colnames(data.lag) <- c("V1lag", "V2lag", "V3lag", "V1", "V2", "V3")
### end simulating time series -------------------------------
## fitting data-generating model in lavaan ------------------
library(lavaan)
model <- '
# estimate all autoregressive
V1 ~ V1lag
V2 ~ V2lag
V3 ~ V3lag
# estimate cross-lagged
V3 ~ V2lag
# estimate contemp
V2 ~ V1
V1 ~ V3
'
fit <- sem(model, data.lag)
summary(fit)
## end fitting data-generating model in lavaan ---------------
## attempting to fit full model with all possible paths
## and then send to regsem. does not work
library(lavaan)
model <- '
# estimate all autoregressive
V1 ~ V1lag
V2 ~ V2lag
V3 ~ V3lag
# estimate all cross-lagged
V1 ~ V2lag
V1 ~ V3lag
V2 ~ V1lag
V2 ~ V3lag
V3 ~ V1lag
V3 ~ V2lag
# estimate all contemp
V1 ~ V2
V2 ~ V1
V1 ~ V3
V3 ~ V1
V2 ~ V3
V3 ~ V2
'
fit <- sem(model, data.lag)
summary(fit)
out <- regsem(fit,type="lasso", gradFun = "ram",pars_pen=c(1:15),max.iter=2000,
lambda = 0.05,optMethod="coord_desc",Start=extractMatrices(fit)$parameters)
fit <- sem(model, data.lag)
out <- regsem(fit,type="lasso", gradFun = "ram",pars_pen=c(1:15),max.iter=2000,
lambda = 0.05,optMethod="coord_desc",Start=extractMatrices(fit)$parameters)
out <- regsem(fit,type="lasso", gradFun = "ram",pars_pen=c(1:15),max.iter=2000,
lambda = 0.15,optMethod="coord_desc",Start=extractMatrices(fit)$parameters)
model <- '
# estimate all autoregressive
V1 ~ V1lag
V2 ~ V2lag
V3 ~ V3lag
# estimate cross-lagged
V3 ~ V2lag
# estimate contemp
V2 ~ V1
V1 ~ V3
'
fit <- sem(model, data.lag)
summary(fit)
out <- regsem(fit,type="none", gradFun = "ram",,max.iter=2000,
lambda = 0,optMethod="coord_desc",Start=extractMatrices(fit)$parameters)
out <- regsem(fit,type="none", gradFun = "ram",max.iter=2000,
lambda = 0,optMethod="none",Start=extractMatrices(fit)$parameters)
out <- regsem(fit,type="none", gradFun = "ram",max.iter=2000,
lambda = 0,optMethod="nlminb",Start=extractMatrices(fit)$parameters)
summary(out)
summary(fit)
fitmeasures(fit)
out <- regsem(fit,type="none", gradFun = "none",max.iter=2000,
lambda = 0,optMethod="nlminb",Start=extractMatrices(fit)$parameters)
summary(out)
parTable(fit)
out <- regsem(fit,type="none", gradFun = "ram",max.iter=2000,
lambda = 0,optMethod="nlminb",Start=extractMatrices(fit)$parameters)
summary(out)
extractMatrices(fit)
model <- '
# estimate all autoregressive
V1 ~ V1lag
V2 ~ V2lag
V3 ~ V3lag
# estimate cross-lagged
V3 ~ V2lag
# estimate contemp
V2 ~ V1
V1 ~ V3
V1~0
'
fit <- sem(model, data.lag)
extractMatrices(fit)
out <- regsem(fit,type="none", gradFun = "ram",max.iter=2000,
lambda = 0,optMethod="nlminb",Start=extractMatrices(fit)$parameters)
summary(out)
library(blavaan);library(modeest);library(regsem)
#mod <- "
#f =~ 0*x1 + 0*x2 + 0*x3 + 0*x + 0.5*x4 + 0.5*x5 + 0.5*x6
#f~~1*f"
#set.seed(1234)
#dat <- simulateData(mod,model.type="cfa",sample.nobs=200)
mod.run <- "
f =~ NA*x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
f~~1*f
"
lav.out <- cfa(mod.run,data.frame(scale(HolzingerSwineford1939[,7:15])))
summary(lav.out)
# ----------------------------------------------
# Bayesian Ridge
# ----------------------------------------------
variances = seq(.0001,by=.5,length.out=30)**3.5
ret = list()
fits <- list()
for(i in 1:length(variances)){
mod.bayes <- '
f =~ NA*x1 + prior("dnorm(0,val)")*x1 +
prior("dnorm(0,val)")*x2 +
prior("dnorm(0,val)")*x3 +
x4 +
x5 +
x6 +
prior("dnorm(0,val)")*x7 +
prior("dnorm(0,val)")*x8 +
prior("dnorm(0,val)")*x9
f~~1*f
x1~1
x2~1
x3~1
x4~1
x5~1
x6~1
x7~1
x8~1
x9~1'
moddd = gsub("val",variances[i],mod.bayes)
bcfa.out <- bcfa(moddd,data=HolzingerSwineford1939,inits="simple",
jagcontrol=list(method="rjparallel",psrf.target = 1.2),
runjags.options(mode.continuous=TRUE))
pars <- bcfa.out@external$runjags$summaries[c(1:3,7:9),]
ret[[i]] <- pars
fits[[i]] <- fitmeasures(bcfa.out)
print(i)
}
ret.pars <- matrix(NA,30,6)
for(i in 1:length(ret)){
ret.pars[i,] <- abs(ret[[i]][,"Mode"])
}
ret.pars
for(i in 1:6){
ret.pars[,i] <- ret.pars[,i]/ret.pars[1,i]
}
plot(variances[1:15],ret.pars[1:15,1],ylim=c(0,1),ylab="Loading/max(Loading)",xlab="Precision",type="l",lty=1,col=1)
for(i in 2:(6)){
lines(variances[1:15],ret.pars[1:15,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
cv.out <- cv_regsem(lav.out,n.lambda=40,jump=0.01,type="ridge",parallel=FALSE,optMethod="coord_desc",gradFun="ram",
tol=1e-4,pars_pen=c(1:3,7:9),multi.iter=3,warm.start=TRUE,mult.start=TRUE,max.iter=2000)
cv.out <- cv_regsem(lav.out,n.lambda=40,jump=0.01,type="ridge",parallel=FALSE,optMethod="coord_desc",gradFun="ram",
tol=1e-4,pars_pen=c(1:3,7:9),multi.iter=3,warm.start=FALSE,mult.start=TRUE,max.iter=2000)
cv.out
cv.out <- cv_regsem(lav.out,n.lambda=40,jump=0.01,type="ridge",parallel=FALSE,optMethod="nlminb",gradFun="ram",
tol=1e-4,pars_pen=c(1:3,7:9),multi.iter=3,warm.start=FALSE,mult.start=TRUE,max.iter=2000)
cv.out
cv.out <- cv_regsem(lav.out,n.lambda=40,jump=0.01,type="ridge",parallel=FALSE,optMethod="nlminb",gradFun="ram",
tol=1e-4,pars_pen=c(1:3,7:9),multi.iter=10,warm.start=FALSE,mult.start=TRUE,max.iter=2000)
cv.out
coef.mat <- abs(cv.out[[1]][,c(1:3,7:9)])
shrink.vals <- cv.out[[2]][,"lambda"]
for(i in 1:6){
coef.mat[,i] <- coef.mat[,i]/coef.mat[1,i]
}
plot(shrink.vals,coef.mat[,1],ylim=c(0,1),ylab="Loading/max(Loading)",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(6)){
lines(shrink.vals,coef.mat[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
cv.out <- cv_regsem(lav.out,n.lambda=40,jump=0.02,type="ridge",parallel=FALSE,optMethod="nlminb",gradFun="none",
tol=1e-4,pars_pen=c(1:3,7:9),multi.iter=100,warm.start=FALSE,mult.start=TRUE,max.iter=2000)
cv.out
coef.mat <- abs(cv.out[[1]][,c(1:3,7:9)])
shrink.vals <- cv.out[[2]][,"lambda"]
for(i in 1:6){
coef.mat[,i] <- coef.mat[,i]/coef.mat[1,i]
}
plot(shrink.vals,coef.mat[,1],ylim=c(0,1),ylab="Loading/max(Loading)",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(6)){
lines(shrink.vals,coef.mat[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
cv.out <- cv_regsem(lav.out,n.lambda=40,jump=0.01,type="ridge",parallel=FALSE,optMethod="nlminb",gradFun="none",
tol=1e-4,pars_pen=c(1:3,7:9),multi.iter=100,warm.start=FALSE,mult.start=TRUE,max.iter=2000)
cv.out
#coef.mat <- abs(cv.out[[1]][cv.out[[2]][,"conv"]==0,c(4+c(1:3,7:9))])
#shrink.vals <- cv.out[[2]][cv.out[[2]][,"conv"]==0,"lambda"]
coef.mat <- abs(cv.out[[1]][,c(1:3,7:9)])
shrink.vals <- cv.out[[2]][,"lambda"]
for(i in 1:6){
coef.mat[,i] <- coef.mat[,i]/coef.mat[1,i]
}
plot(shrink.vals,coef.mat[,1],ylim=c(0,1),ylab="Loading/max(Loading)",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(6)){
lines(shrink.vals,coef.mat[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
cv.out <- cv_regsem(lav.out,n.lambda=40,jump=0.01,type="ridge",parallel=FALSE,optMethod="nlminb",gradFun="ram",
tol=1e-4,pars_pen=c(1:3,7:9),multi.iter=100,warm.start=FALSE,mult.start=TRUE,max.iter=2000)
cv.out
#coef.mat <- abs(cv.out[[1]][cv.out[[2]][,"conv"]==0,c(4+c(1:3,7:9))])
#shrink.vals <- cv.out[[2]][cv.out[[2]][,"conv"]==0,"lambda"]
coef.mat <- abs(cv.out[[1]][,c(1:3,7:9)])
shrink.vals <- cv.out[[2]][,"lambda"]
for(i in 1:6){
coef.mat[,i] <- coef.mat[,i]/coef.mat[1,i]
}
plot(shrink.vals,coef.mat[,1],ylim=c(0,1),ylab="Loading/max(Loading)",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(6)){
lines(shrink.vals,coef.mat[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
cv.out <- cv_regsem(lav.out,n.lambda=40,jump=0.02,type="ridge",parallel=FALSE,optMethod="nlminb",gradFun="ram",
tol=1e-4,pars_pen=c(1:3,7:9),multi.iter=100,warm.start=FALSE,mult.start=TRUE,max.iter=2000)
cv.out
#coef.mat <- abs(cv.out[[1]][cv.out[[2]][,"conv"]==0,c(4+c(1:3,7:9))])
#shrink.vals <- cv.out[[2]][cv.out[[2]][,"conv"]==0,"lambda"]
coef.mat <- abs(cv.out[[1]][,c(1:3,7:9)])
shrink.vals <- cv.out[[2]][,"lambda"]
for(i in 1:6){
coef.mat[,i] <- coef.mat[,i]/coef.mat[1,i]
}
plot(shrink.vals,coef.mat[,1],ylim=c(0,1),ylab="Loading/max(Loading)",xlab="Penalty",type="l",lty=1,col=1)
for(i in 2:(6)){
lines(shrink.vals,coef.mat[,i],lty=i,col=1)
#points(mat[,(nload)])
}
abline(a=0,b=0)
