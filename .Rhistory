SampMean
SampMean <- model@SampleStats@mean[][[1]]
SampMean
model@SampleStats@mean
model@SampleStats
mm[mm>0]
mm>0
str(outt)
model@SampleStats@mean.x
model@SampleStats@mean.x[[1]][1]
model@SampleStats@mean.x[[1]]
match(SampMean,model@SampleStats@mean.x[[1]])
model@SampleStats
match(round(SampMean,8),round(model@SampleStats@mean.x[[1]],8))
round(model@SampleStats@mean.x[[1]],8)
match(round(SampMean,10),round(model@SampleStats@mean.x[[1]],10))
round(model@SampleStats@mean.x[[1]],10)
match(round(SampMean,15),round(model@SampleStats@mean.x[[1]],15))
SampMean <- model@SampleStats@mean[][[1]]
mm = extractMatrices(model)$A[,"1"]
mm
names(mm > 0)
mm >0
names(mm[mm > 0])
model@SampleStats
str(model)
match(names(mm[mm > 0]),model@Data@ov$name)
ss = match(names(mm[mm > 0]),model@Data@ov$name)
ss
SampMean[-c(ss)] = 0
SampMean
library(regsem)
fit1 <- regsem(outt,lambda=0,type="lasso",gradFun="ram")
summary(fit1)
outt = cfa(mod,HS,meanstructure=TRUE)
fit1 <- regsem(outt,lambda=0,type="lasso",gradFun="ram")
summary(fit1)
fitMeasures(outt)
outt = cfa(mod,HS)
fitMeasures(outt)
fit1 <- regsem(outt,lambda=0,type="lasso",gradFun="ram")
summary(fit1)
xx = list()
for(i in 1:100){
xx[i] = paste("x", i, sep = "")
}
uu = list()
for(i in 1:length(xx)){
uu[i] = paste("0*",xx[i],sep="")
}
reg.list = paste(uu,collapse="+")
sim.list = list()
sim.list[[1]] = paste(paste("f1"," ~ "), reg.list)
sim.list[[2]] = "f1 =~ y1 + 0.8*y2 + 1.2*y3 + 0.8*y4 + 0.5*y5 + 1.5*y6
"
sim.list[[3]] = "
f1 ~ 1*x1000 + 1*x1001 + 1*x1002 + 1*x1003 + 1*x1004 + 1*x1005
"
pop.mod = " "
for(i in 1:length(sim.list)){
pop.mod = paste(pop.mod,sim.list[[i]],sep="\n")
}
dat <- simulateData(pop.mod,sample.nobs=300,fixed.x=TRUE)
reg.list2 = paste(xx,collapse="+")
run.list = list()
run.list[[1]] = paste(paste("f1"," ~ "), reg.list2)
run.list[[2]] = "
f1 ~ x1000 + x1001 + x1002 + x1003 + x1004 + x1005
"
run.list[[3]] = "f1 =~ y1 + y2 + y3 + y4 + y5 + y6
"
run.mod = " "
for(i in 1:length(run.list)){
run.mod = paste(run.mod,run.list[[i]],sep="\n")
}
#42 minutes
system.time(lav.out <- lavaan::sem(run.mod,dat,meanstructure=TRUE))
fitmeasures(lav.out)
reg.out = multi_optim(lav.out,lambda=0.0,type="none",#pars_pen=c(1:106),
max.try=100,gradFun="ram",max.iter = 1000000)
4000/60
library(lavaan)
HS <- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod <- '
f ~ x7 + x8 + x9
f =~ NA*x1 + x2 + x3 + x4 + x5 + x6
f~~1*f
'
outt = cfa(mod,HS)
system.time(cfa(mod,HS,meanstructure=TRUE))
summary(outt)
fitMeasures(outt)
fit1 <- regsem(outt,lambda=0,type="lasso",gradFun="ram")
summary(fit1)
system.time(cfa(mod,HS))
fitMeasures(outt)
fit1 <- regsem(outt,lambda=0,type="lasso",gradFun="ram")
summary(fit1)
xx = list()
for(i in 1:100){
xx[i] = paste("x", i, sep = "")
}
uu = list()
for(i in 1:length(xx)){
uu[i] = paste("0*",xx[i],sep="")
}
reg.list = paste(uu,collapse="+")
sim.list = list()
sim.list[[1]] = "f1 =~ y1 + 0.8*y2 + 1.2*y3 + 0.8*y4 + 0.5*y5 + 1.5*y6
"
sim.list[[2]] = "
f1 ~ 1*x1000 + 1*x1001 + 1*x1002 + 1*x1003 + 1*x1004 + 1*x1005
"
sim.list[[3]] = paste(paste("f1"," ~ "), reg.list)
pop.mod = " "
for(i in 1:length(sim.list)){
pop.mod = paste(pop.mod,sim.list[[i]],sep="\n")
}
dat <- simulateData(pop.mod,sample.nobs=300,fixed.x=TRUE)
reg.list2 = paste(xx,collapse="+")
run.list = list()
run.list[[1]] = "f1 =~ y1 + y2 + y3 + y4 + y5 + y6
"
run.list[[2]] = paste(paste("f1"," ~ "), reg.list2)
run.list[[3]] = "
f1 ~ x1000 + x1001 + x1002 + x1003 + x1004 + x1005
"
run.mod = " "
for(i in 1:length(run.list)){
run.mod = paste(run.mod,run.list[[i]],sep="\n")
}
#42 minutes
system.time(lav.out <- lavaan::sem(run.mod,dat,meanstructure=TRUE))
summary(lav.out)
fitmeasures(lav.out)
#fitted(lav.out)
# find the parameter numbers
extractMatrices(lav.out)$A[c("f1"),]
# only lasso working at this time
# ridge with gradeFun="none" is super slow
reg.out = multi_optim(lav.out,lambda=0.0,type="none",#pars_pen=c(1:106),
max.try=100,gradFun="ram",max.iter = 1000000)
summary(reg.out)
summary(lav.out)
fitmeasures(lav.out)
library(lavaan)
HS <- data.frame(scale(HolzingerSwineford1939[,7:15]))
HS[1,1] <- NA
mod <- '
f =~ NA*x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
f~~1*f
'
outt = cfa(mod,HS,missing="fiml")
summary(outt)
fitMeasures(outt)
SampMean <- outt@SampleStats@mean[][[1]]
# have to include intercepts
fit = 0
ImpCov = fitted(outt)$cov
for(i in 1:nrow(HS)){
person1 = HS[i,]
ind1 = is.na(person1)==FALSE
K = sum(ind1)
sub1 = person1[ind1] - SampMean[ind1]
indFit = K - 0.5* log(det(ImpCov)) - 0.5* t(sub1) %*% solve(ImpCov[ind1,ind1]) %*% sub1
fit = fit + indFit
}
-2*fit
SampMean
SampMean = rep(0,9)
# have to include intercepts
fit = 0
ImpCov = fitted(outt)$cov
for(i in 1:nrow(HS)){
person1 = HS[i,]
ind1 = is.na(person1)==FALSE
K = sum(ind1)
sub1 = person1[ind1] - SampMean[ind1]
indFit = K - 0.5* log(det(ImpCov)) - 0.5* t(sub1) %*% solve(ImpCov[ind1,ind1]) %*% sub1
fit = fit + indFit
}
-2*fit
SampMean <- outt@SampleStats@mean[][[1]]
SampMean = rep(0,9)
# have to include intercepts
fit = 0
ImpCov = fitted(outt)$cov
for(i in 1:nrow(HS)){
person1 = HS[i,]
ind1 = is.na(person1)==FALSE
K = 0 #sum(ind1)
sub1 = person1[ind1] - SampMean[ind1]
indFit = K - 0.5* log(det(ImpCov)) - 0.5* t(sub1) %*% solve(ImpCov[ind1,ind1]) %*% sub1
fit = fit + indFit
}
-2*fit
str(outt)
miss = outt@Data@MP
miss2 = outt@SampleStats@missing
str(outt@Data)
outt@Data@MP
miss = outt@Data$MP
miss = outt@Data$RP
miss = outt@Data@Mp
str(miss)
str(miss2)
estimator.FIML <- function(Sigma.hat=NULL, Mu.hat=NULL, M=NULL, h1=NULL) {
npatterns <- length(M)
fx.p <- numeric(npatterns)
w.p <- numeric(npatterns)
# for each missing pattern, combine cases and compute raw loglikelihood
for(p in 1:npatterns) {
SX <- M[[p]][["SX"]]
MX <- M[[p]][["MX"]]
w.p[p] <- nobs <- M[[p]][["nobs"]]
var.idx <- M[[p]][["var.idx"]]
# note: if a decent 'sweep operator' was available (in fortran)
# we might win some time by 'updating' the inverse by sweeping
# out the changed patterns... (but to get the logdet, we need
# to do it one column at a time?)
#cat("FIML: pattern ", p, "\n")
#print(Sigma.hat[var.idx, var.idx])
Sigma.inv <- inv.chol(Sigma.hat[var.idx, var.idx], logdet=TRUE)
Sigma.log.det <- attr(Sigma.inv, "logdet")
Mu <- Mu.hat[var.idx]
TT <- SX + tcrossprod(MX - Mu)
trace <- sum(Sigma.inv * TT)
fx.p[p] <- Sigma.log.det + trace
}
fx <- weighted.mean(fx.p, w=w.p)
# ajust for h1
if(!is.null(h1)) {
fx <- fx - h1
# no negative values
if(fx < 0.0) fx <- 0.0
}
fx
}
str(miss2)
miss2$X
miss2[[1]]$X
miss2[[]]$X
miss2[[1]]
miss2[[1]][[1]]$X
M = miss2[[1]][[1]]$X
length(M)
str(M)
str(miss2)
str(miss)
M = miss2
estimator.FIML(Sigma.hat=ImpCov,Mu.hat=SampMean,M=miss2)
estimator.FIML(Sigma.hat=ImpCov,Mu.hat=SampMean,M=miss2,h1=0)
miss2
str(miss2)
length(miss2)
str()
str(outt$SampleStats)
str(outt@SampleStats)
miss2 = outt@SampleStats@missing[[1]]
length(miss2)
estimator.FIML(Sigma.hat=ImpCov,Mu.hat=SampMean,M=miss2)
estimator.FIML <- function(Sigma.hat=NULL, Mu.hat=NULL, M=NULL, h1=NULL) {
npatterns <- length(M)
fx.p <- numeric(npatterns)
w.p <- numeric(npatterns)
# for each missing pattern, combine cases and compute raw loglikelihood
for(p in 1:npatterns) {
SX <- M[[p]][["SX"]]
MX <- M[[p]][["MX"]]
w.p[p] <- nobs <- M[[p]][["nobs"]]
var.idx <- M[[p]][["var.idx"]]
# note: if a decent 'sweep operator' was available (in fortran)
# we might win some time by 'updating' the inverse by sweeping
# out the changed patterns... (but to get the logdet, we need
# to do it one column at a time?)
#cat("FIML: pattern ", p, "\n")
#print(Sigma.hat[var.idx, var.idx])
Sigma.inv <- lavaan::inv.chol(Sigma.hat[var.idx, var.idx], logdet=TRUE)
Sigma.log.det <- attr(Sigma.inv, "logdet")
Mu <- Mu.hat[var.idx]
TT <- SX + tcrossprod(MX - Mu)
trace <- sum(Sigma.inv * TT)
fx.p[p] <- Sigma.log.det + trace
}
fx <- weighted.mean(fx.p, w=w.p)
# ajust for h1
if(!is.null(h1)) {
fx <- fx - h1
# no negative values
if(fx < 0.0) fx <- 0.0
}
fx
}
estimator.FIML(Sigma.hat=ImpCov,Mu.hat=SampMean,M=miss2)
estimator.FIML <- function(Sigma.hat=NULL, Mu.hat=NULL, M=NULL, h1=NULL) {
npatterns <- length(M)
fx.p <- numeric(npatterns)
w.p <- numeric(npatterns)
# for each missing pattern, combine cases and compute raw loglikelihood
for(p in 1:npatterns) {
SX <- M[[p]][["SX"]]
MX <- M[[p]][["MX"]]
w.p[p] <- nobs <- M[[p]][["nobs"]]
var.idx <- M[[p]][["var.idx"]]
# note: if a decent 'sweep operator' was available (in fortran)
# we might win some time by 'updating' the inverse by sweeping
# out the changed patterns... (but to get the logdet, we need
# to do it one column at a time?)
#cat("FIML: pattern ", p, "\n")
#print(Sigma.hat[var.idx, var.idx])
#Sigma.inv <- inv.chol(Sigma.hat[var.idx, var.idx], logdet=TRUE)
Sigma.inv <- chol2inv(chol(Sigma.hat[var.idx, var.idx]))
Sigma.log.det <- attr(Sigma.inv, "logdet")
Mu <- Mu.hat[var.idx]
TT <- SX + tcrossprod(MX - Mu)
trace <- sum(Sigma.inv * TT)
fx.p[p] <- Sigma.log.det + trace
}
fx <- weighted.mean(fx.p, w=w.p)
# ajust for h1
if(!is.null(h1)) {
fx <- fx - h1
# no negative values
if(fx < 0.0) fx <- 0.0
}
fx
}
estimator.FIML(Sigma.hat=ImpCov,Mu.hat=SampMean,M=miss2)
inv.chol <- function(S, logdet=FALSE) {
cS <- chol(S)
#if( inherits(cS, "try-error") ) {
#    print(S)
#    warning("lavaan WARNING: symmetric matrix is not positive symmetric!")
#}
S.inv <- chol2inv( cS )
if(logdet) {
diag.cS <- diag(cS)
attr(S.inv, "logdet") <- sum(log(diag.cS*diag.cS))
}
S.inv
}
estimator.FIML <- function(Sigma.hat=NULL, Mu.hat=NULL, M=NULL, h1=NULL) {
npatterns <- length(M)
fx.p <- numeric(npatterns)
w.p <- numeric(npatterns)
# for each missing pattern, combine cases and compute raw loglikelihood
for(p in 1:npatterns) {
SX <- M[[p]][["SX"]]
MX <- M[[p]][["MX"]]
w.p[p] <- nobs <- M[[p]][["nobs"]]
var.idx <- M[[p]][["var.idx"]]
# note: if a decent 'sweep operator' was available (in fortran)
# we might win some time by 'updating' the inverse by sweeping
# out the changed patterns... (but to get the logdet, we need
# to do it one column at a time?)
#cat("FIML: pattern ", p, "\n")
#print(Sigma.hat[var.idx, var.idx])
Sigma.inv <- inv.chol(Sigma.hat[var.idx, var.idx], logdet=TRUE)
#Sigma.inv <- chol2inv(chol(Sigma.hat[var.idx, var.idx]))
Sigma.log.det <- attr(Sigma.inv, "logdet")
Mu <- Mu.hat[var.idx]
TT <- SX + tcrossprod(MX - Mu)
trace <- sum(Sigma.inv * TT)
fx.p[p] <- Sigma.log.det + trace
}
fx <- weighted.mean(fx.p, w=w.p)
# ajust for h1
if(!is.null(h1)) {
fx <- fx - h1
# no negative values
if(fx < 0.0) fx <- 0.0
}
fx
}
estimator.FIML(Sigma.hat=ImpCov,Mu.hat=SampMean,M=miss2)
fitmeasures(outt)
logl.MVN.complete <- function(Sigma, Mu,
X=NULL, data.cov=NULL, data.mean=NULL) {
if(is.null(data.cov)) {
stopifnot(!is.null(X))
nobs <- nrow(X)
data.cov <- cov(X) * (nobs-1)/nobs
data.mean <- colMeans(X)
}
Sigma.inv <- inv.chol(Sigma, logdet=TRUE)
Sigma.log.det <- attr(Sigma.inv, "logdet")
diff <- as.matrix(data.mean - Mu)
TT <- data.cov + tcrossprod(diff)
logl <- Sigma.log.det + sum(TT * Sigma.inv) # - S.log.det - nvar
logl <- 0.5 * logl
logl
}
logl.MVN.complete(Sigma=ImpCov,Mu=SampMean,X=HS,data.cov=cov(HS),data.mean(SampMean))
logl.MVN.complete(Sigma=ImpCov,Mu=SampMean,X=HS,data.cov=cov(HS),data.mean=SampMean)
logl.MVN.casewise(Sigma=ImpCov,Mu=SampMean,X=HS)
logl.MVN.casewise <- function(Sigma, Mu, X) {
Sigma.inv <- inv.chol(Sigma, logdet=TRUE)
Sigma.log.det <- attr(Sigma.inv, "logdet")
tmp1 <- tmp2 <- logl <- 0.0
for(i in 1:nrow(X)) {
diff <- as.matrix(X[i,] - Mu)
Tmp1 <- Sigma.log.det
Tmp2 <- (t(diff) %*% Sigma.inv %*% diff)
tmp1 <- tmp1 + Tmp1
tmp2 <- tmp2 + Tmp2
}
logl <- -1 * as.numeric( -0.5 * tmp1  -0.5* tmp2 ) * 1/nrow(X)
logl
}
logl.MVN.casewise(Sigma=ImpCov,Mu=SampMean,X=HS)
ImpCov
str(HS)
logl.MVN.casewise(Sigma=ImpCov,Mu=SampMean,X=HS[2:301,])
HS[2:301,]
SampMean
length(SampMean)
str(ImpCov)
logl.MVN.casewise(Sigma=matrix(ImpCov),Mu=SampMean,X=HS)
matrix(ImpCov)
matrix(ImpCov,9,9)
logl.MVN.casewise(Sigma=matrix(ImpCov,9,9),Mu=SampMean,X=HS)
logl.MVN.casewise(Sigma=matrix(ImpCov,9,9),Mu=SampMean,X=HS[2:301,])
Sigma=matrix(ImpCov,9,9)
Mu=SampMean
X=HS[2:301,]
Sigma.inv <- inv.chol(Sigma, logdet=TRUE)
Sigma.log.det <- attr(Sigma.inv, "logdet")
tmp1 <- tmp2 <- logl <- 0.0
for(i in 1:nrow(X)) {
diff <- as.matrix(X[i,] - Mu)
Tmp1 <- Sigma.log.det
Tmp2 <- (t(diff) %*% Sigma.inv %*% diff)
tmp1 <- tmp1 + Tmp1
tmp2 <- tmp2 + Tmp2
}
i
diff <- as.matrix(X[i,] - Mu)
Tmp1 <- Sigma.log.det
Tmp2 <- (t(diff) %*% Sigma.inv %*% diff)
diff
Sigma.inv
diff
Sigma.inv %*% diff
Sigma.log.det
inv.chol(Sigma, logdet=TRUE)
str(Sigma.inv)
t(diff) %*% Sigma.inv
Sigma.inv[1:9,1:9]
Sigma.inv = Sigma.inv[1:9,1:9]
tmp1 <- tmp2 <- logl <- 0.0
for(i in 1:nrow(X)) {
diff <- as.matrix(X[i,] - Mu)
Tmp1 <- Sigma.log.det
Tmp2 <- (t(diff) %*% Sigma.inv %*% diff)
tmp1 <- tmp1 + Tmp1
tmp2 <- tmp2 + Tmp2
}
str(diff)
t(diff)
diff
t(diff) %*% diff
t(diff) %*% Sigma.inv
str(Sigma.inv)
diff
Tmp2 <- (t(diff) %*% Sigma.inv %*% diff)
Sigma.inv <- inv.chol(Sigma, logdet=TRUE)
Tmp2 <- (t(diff) %*% Sigma.inv %*% diff)
Tmp2 <- (diff %*% Sigma.inv %*% t(diff))
Tmp2
logl.MVN.casewise <- function(Sigma, Mu, X) {
Sigma.inv <- inv.chol(Sigma, logdet=TRUE)
Sigma.log.det <- attr(Sigma.inv, "logdet")
#Sigma.inv = Sigma.inv[1:9,1:9]
tmp1 <- tmp2 <- logl <- 0.0
for(i in 1:nrow(X)) {
diff <- as.matrix(X[i,] - Mu)
Tmp1 <- Sigma.log.det
Tmp2 <- (diff %*% Sigma.inv %*% t(diff))
tmp1 <- tmp1 + Tmp1
tmp2 <- tmp2 + Tmp2
}
logl <- -1 * as.numeric( -0.5 * tmp1  -0.5* tmp2 ) * 1/nrow(X)
logl
}
logl.MVN.casewise(Sigma=matrix(ImpCov,9,9),Mu=SampMean,X=HS[2:301,])
logl.MVN.casewise(Sigma=matrix(ImpCov,9,9),Mu=SampMean,X=HS[1:301,])
logl.MVN.casewise(Sigma=matrix(ImpCov,9,9),Mu=SampMean,X=HS[2:301,])
estimator.FIML(Sigma.hat=ImpCov,Mu.hat=SampMean,M=miss2)
3.46*2
log(6.92)
exp(6.92)
log(-6)
N=300
c <- N*p/2 * log(2 * pi)
N=300;p=9
c <- N*p/2 * log(2 * pi)
logl_sat = -c -(N/2) * log(det(cov(HS[2:301,]))) - (N/2)*p
logl = -N * (fit- logl_sat/N)
logl
N=300;p=9;fit=6.94
c <- N*p/2 * log(2 * pi)
logl_sat = -c -(N/2) * log(det(cov(HS[2:301,]))) - (N/2)*p
logl = -N * (fit- logl_sat/N)
logl
N=300;p=9;fit=3.46
c <- N*p/2 * log(2 * pi)
logl_sat = -c -(N/2) * log(det(cov(HS[2:301,]))) - (N/2)*p
logl = -N * (fit- logl_sat/N)
logl
estimator.FIML(Sigma.hat=ImpCov,Mu.hat=SampMean,M=miss2)
exp(6.94)
fitmeasures(outt)
