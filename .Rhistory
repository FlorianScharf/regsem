mediators <- c("Outstate","Room.Board","Books","Personal","S.F.Ratio","Expend")
out <- xmed_cat(Data,iv,mediators,dv)
College1 = College[which(College$Private=="Yes"),]
str(College1)
colnames(College1)
Data = data.frame(scale(College[c(3,9:12,15,17,18)]))
Data$Grad.Rate <- ifelse(Data$Grad.Rate > 0,1,0)
summary(Data)
Data$Grad.Rate <- as.factor(Data$Grad.Rate)
model1 <-
' # direct effect (c)
Grad.Rate ~ c*Accept
# mediators
Outstate ~ a1*Accept
Room.Board ~ a2*Accept
Books ~ a3*Accept
Personal ~ a4*Accept
S.F.Ratio ~ a5*Accept
Expend ~ a6*Accept
Grad.Rate ~ b1*Outstate + b2*Room.Board + b3*Books + b4*Personal + b5*S.F.Ratio + b6*Expend
# indirect effects (a*b)
a1b1 := a1*b1
a2b2 := a2*b2
a3b3 := a3*b3
a4b4 := a4*b4
a5b5 := a5*b5
a6b6 := a6*b6
# total effect (c_prime)
total := c + (a1*b1) + (a2*b2) + (a3*b3) + (a4*b4) + (a5*b5) + (a6*b6)
'
#p-value approach using delta method standard errors
fit.delta = sem(model1,data=Data,fixed.x=T)
summary(fit.delta)
fit.delta = sem(model1,data=Data,fixed.x=T,ordered="Grad.Rate")
summary(fit.delta)
fit.delta = sem(model1,data=Data,fixed.x=T,ordered="Grad.Rate",parameterization="Delta")
fit.delta = sem(model1,data=Data,fixed.x=T,ordered="Grad.Rate",parameterization="Theta")
str(Data)
iv <- "Accept"
dv <- "Grad.Rate"
mediators <- c("Outstate","Room.Board","Books","Personal","S.F.Ratio","Expend")
out <- xmed_cat(Data,iv,mediators,dv)
summary(Data)
Data2 <- Data
Data2$Grad.Rate <- as.numeric(Data2$Grad.Rate)
out <- xmed_cat(Data2,iv,mediators,dv)
out
library(regsem)
out <- xmed_cat(Data,iv,mediators,dv)
out
Data = data.frame(scale(College[c(3,9:12,18)]))
str(Data)
Data = data.frame(scale(College[c(3,9:12,18)]))
Data$Grad.Rate <- ifelse(Data$Grad.Rate > 0,1,0)
Data$Grad.Rate <- as.factor(Data$Grad.Rate)
#lavaan model with all mediators
model1 <-
' # direct effect (c_prime)
Grad.Rate ~ c_prime*Accept
# mediators
Outstate ~ a1*Accept
Room.Board ~ a2*Accept
Books ~ a3*Accept
Expend ~ a6*Accept
Grad.Rate ~ b1*Outstate + b2*Room.Board + b3*Books + b6*Expend
# indirect effects (a*b)
a1b1 := a1*b1
a2b2 := a2*b2
a3b3 := a3*b3
a6b6 := a6*b6
# total effect (c)
total := c_prime + (a1*b1) + (a2*b2) + (a3*b3) + (a6*b6)
'
#p-value approach using delta method standard errors
fit.delta = sem(model1,data=Data,fixed.x=T,ordered="Grad.Rate")
College1 = College[which(College$Private=="Yes"),]
Data = data.frame(scale(College1[c("Grad.Rate","Accept","Outstate","Room.Board","Books","Expend")]))
Data$Grad.Rate <- ifelse(Data$Grad.Rate > 0,1,0)
Data$Grad.Rate <- as.factor(Data$Grad.Rate)
#lavaan model with all mediators
model1 <-
' # direct effect (c_prime)
Grad.Rate ~ c_prime*Accept
# mediators
Outstate ~ a1*Accept
Room.Board ~ a2*Accept
Books ~ a3*Accept
Expend ~ a6*Accept
Grad.Rate ~ b1*Outstate + b2*Room.Board + b3*Books + b6*Expend
# indirect effects (a*b)
a1b1 := a1*b1
a2b2 := a2*b2
a3b3 := a3*b3
a6b6 := a6*b6
# total effect (c)
c := c_prime + (a1*b1) + (a2*b2) + (a3*b3) + (a6*b6)
'
#p-value approach using delta method standard errors
fit.delta = sem(model1,data=Data,fixed.x=T,ordered="Grad.Rate")
summary(fit.delta)
iv <- "Accept"
dv <- "Grad.Rate"
mediators <- c("Outstate","Room.Board","Books","Expend")
out <- xmed_cat(Data,iv,mediators,dv)
out
# example
library(ISLR)
College1 = College[which(College$Private=="Yes"),]
Data = data.frame(scale(College1[c("Grad.Rate","Accept","Outstate","Room.Board","Books","Expend")]))
Data$Grad.Rate <- ifelse(Data$Grad.Rate > 0,1,0)
Data$Grad.Rate <- as.factor(Data$Grad.Rate)
#lavaan model with all mediators
model1 <-
' # direct effect (c_prime)
Grad.Rate ~ c_prime*Accept
# mediators
Outstate ~ a1*Accept
Room.Board ~ a2*Accept
Books ~ a3*Accept
Expend ~ a6*Accept
Grad.Rate ~ b1*Outstate + b2*Room.Board + b3*Books + b6*Expend
# indirect effects (a*b)
a1b1 := a1*b1
a2b2 := a2*b2
a3b3 := a3*b3
a6b6 := a6*b6
# total effect (c)
c := c_prime + (a1*b1) + (a2*b2) + (a3*b3) + (a6*b6)
'
#p-value approach using delta method standard errors
fit.delta = sem(model1,data=Data,fixed.x=T,ordered="Grad.Rate")
summary(fit.delta)
iv <- "Accept"
dv <- "Grad.Rate"
mediators <- c("Outstate","Room.Board","Books","Expend")
out <- xmed_cat(Data,iv,mediators,dv)
out
library(regsem)
# example
library(ISLR)
College1 = College[which(College$Private=="Yes"),]
Data = data.frame(scale(College1[c("Grad.Rate","Accept","Outstate","Room.Board","Books","Expend")]))
Data$Grad.Rate <- ifelse(Data$Grad.Rate > 0,1,0)
Data$Grad.Rate <- as.factor(Data$Grad.Rate)
#lavaan model with all mediators
model1 <-
' # direct effect (c_prime)
Grad.Rate ~ c_prime*Accept
# mediators
Outstate ~ a1*Accept
Room.Board ~ a2*Accept
Books ~ a3*Accept
Expend ~ a6*Accept
Grad.Rate ~ b1*Outstate + b2*Room.Board + b3*Books + b6*Expend
# indirect effects (a*b)
a1b1 := a1*b1
a2b2 := a2*b2
a3b3 := a3*b3
a6b6 := a6*b6
# total effect (c)
c := c_prime + (a1*b1) + (a2*b2) + (a3*b3) + (a6*b6)
'
#p-value approach using delta method standard errors
fit.delta = sem(model1,data=Data,fixed.x=T,ordered="Grad.Rate")
summary(fit.delta)
iv <- "Accept"
dv <- "Grad.Rate"
mediators <- c("Outstate","Room.Board","Books","Expend")
out <- xmed_cat(Data,iv,mediators,dv)
out
library(regsem)
setwd("C:/Users/RJacobucci/Documents/GitHub/mimic_regsem")
setwd("C:/Users/Ross/Documents/GitHub/mimic_regsem")
setwd("C:/Users/jacobucc/Documents/GitHub/mimic_regsem")
library(lavaan)
library(qgraph)
library(semPlot)
library(psych)
library(regsem)
library(lmtest)
library(ggplot2)
library(reshape2)
library(semTools)
#Here one reads in the data - As I can't share it yet I created a dummy dataset with same means and covs.
#Parameter estimates are identical down to the third decimal so for now we can just use the dummy data (for final paper just rerun with the 'real' - only difference would be skewness and nonlinearities but those are negligible)
#datacamcan<-read.csv('CamCAN_cogneuro_data_Ross2017-03-16.csv')  #Reads in real data
datacamcan<-read.csv('schmamcandat2017-03-16.csv')
colnames(datacamcan)[3:50]<-print(paste('gm',1:48,sep=''))        #Unify grey matter labels for easier syntax
colnames(datacamcan)[51:98]<-print(paste('fa',1:48,sep=''))       #Unify grey matter labels for easier syntax
datacamcan$simpred1<-datacamcan$VSTMcolour_K_ss3+rnorm(708,.5,.5) #add dummy predictors for reference
datacamcan$simpred2<-datacamcan$VSTMcolour_K_ss3+rnorm(708,.5,.5) #add dummy predictors for reference
#Below the syntax to fit normal ML and regsem MIMIC models to predict a single LV (vstmlv) measured by three observables
#Syntax below is to use white matter (fa) and grey matter (gm) to predict a single LV.
#Total R^2 for FA predicting vstmlv is ~38% (versus 8% with noise), and ~27% for gm
#Most exciting would be to include both of course
# standardize variables
X = as.matrix(datacamcan[,99:101]),
cov = as.matrix(datacamcan[,51:98])
data.std <- data.frame(scale(datacamcan[,c(51:101)]))
#############Predicting VSTM: White matter (48 ROIS)
vstmCFA_WM<-'
vstmlv=~VSTMcolour_K_ss2+VSTMcolour_K_ss3+VSTMcolour_K_ss4
vstmlv~fa 1 +fa 2 +fa 3 +fa 4 +fa 5 +fa 6 +fa 7 +fa 8 +fa 9 +fa 10 +fa 11 +fa 12 +fa 13 +fa 14 +fa 15 +fa 16 +fa 17 +fa 18 +fa 19 +fa 20 +fa 21 +fa 22 +fa 23 +fa 24 +fa 25 +fa 26 +fa 27 +fa 28 +fa 29 +fa 30 +fa 31 +fa 32 +fa 33 +fa 34 +fa 35 +fa 36 +fa 37 +fa 38 +fa 39 +fa 40 +fa 41 +fa 42 +fa 43 +fa 44 +fa 45 +fa 46 +fa 47 +fa 48
'
fitvstm_WM <- cfa(vstmCFA_WM, data=data.std, estimator='mlr',missing='fiml')
summary(fitvstm_WM, fit.measures=TRUE, standardized=TRUE, rsquare=TRUE)
#regsem
lav.out_WM<-try(lavaan::sem(vstmCFA_WM,data.std,fixed.x=TRUE,meanstructure=FALSE),silent=TRUE)
A <- extractMatrices(lav.out_WM)$A
A[A!=0]
#cov.test= cov(data.test[,c(51:98,100:102)],use="complete.obs")
#tt = regsem(lav.out_WM)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=15,jump=.1,tol=1e-6,type="enet",alpha=1,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=15,jump=.1,tol=1e-6,type="enet",alpha=0.5,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=15,jump=.075,tol=1e-6,type="enet",alpha=0.5,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM
summary(reg.out1_WM)
summary(reg.out1_WM,fit="BIC")
reg.out1_WM
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=15,jump=.075,tol=1e-6,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=15,jump=.05,tol=1e-6,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=30,jump=.025,tol=1e-6,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=30,jump=.025,tol=1e-8,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=30,jump=.025,tol=1e-4,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=30,jump=.025,tol=1e-4,type="enet",alpha=1,pars_pen=c(3:50),quasi=FALSE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=30,jump=.025,tol=1e-4,type="enet",alpha=0,pars_pen=c(3:50),quasi=FALSE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=30,jump=.025,tol=1e-4,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
reg.out1_WM
library(regsem)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=30,jump=.025,tol=1e-4,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
reg.out1_WM
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=30,jump=.025,tol=1e-4,type="enet",alpha=1,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
reg.out1_WM
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=10,jump=.025,tol=1e-4,type="enet",alpha=1,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=10,jump=.025,tol=1e-4,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
reg.out1_WM
plot(reg.out1_WM)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=10,jump=.1,tol=1e-4,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=FALSE,solver=FALSE,hessFun="none")
reg.out1_WM
library(regsem)
?cv_regsem
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=10,jump=.1,tol=1e-4,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=10,jump=.05,tol=1e-4,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
library(regsem)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=10,jump=.05,tol=1e-4,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=20,jump=.05,tol=1e-4,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
summary(reg.out1_WM,fit="BIC") # problem
reg.out1_WM
library(regsem)
# enet, alpha=0.5 has problems converging at higher than 15 lambdas at 0.075 jump
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=20,jump=.05,tol=1e-4,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
reg.out1_WM
plot(reg.out1_WM)
library(regsem)
setwd("C:/Users/RJacobucci/Documents/GitHub/mimic_regsem")
setwd("C:/Users/Ross/Documents/GitHub/mimic_regsem")
setwd("C:/Users/jacobucc/Documents/GitHub/mimic_regsem")
library(lavaan)
library(qgraph)
library(semPlot)
library(psych)
library(regsem)
library(lmtest)
library(ggplot2)
library(reshape2)
library(semTools)
#datacamcan<-read.csv('CamCAN_cogneuro_data_Ross2017-03-16.csv')  #Reads in real data
datacamcan<-read.csv('schmamcandat2017-03-16.csv')
colnames(datacamcan)[3:50]<-print(paste('gm',1:48,sep=''))        #Unify grey matter labels for easier syntax
colnames(datacamcan)[51:98]<-print(paste('fa',1:48,sep=''))       #Unify grey matter labels for easier syntax
datacamcan$simpred1<-datacamcan$VSTMcolour_K_ss3+rnorm(708,.5,.5) #add dummy predictors for reference
datacamcan$simpred2<-datacamcan$VSTMcolour_K_ss3+rnorm(708,.5,.5) #add dummy predictors for reference
#Below the syntax to fit normal ML and regsem MIMIC models to predict a single LV (vstmlv) measured by three observables
#Syntax below is to use white matter (fa) and grey matter (gm) to predict a single LV.
#Total R^2 for FA predicting vstmlv is ~38% (versus 8% with noise), and ~27% for gm
#Most exciting would be to include both of course
# standardize variables
X = as.matrix(datacamcan[,99:101]),
cov = as.matrix(datacamcan[,51:98])
data.std <- data.frame(scale(datacamcan[,c(51:101)]))
#############Predicting VSTM: White matter (48 ROIS)
vstmCFA_WM<-'
vstmlv=~VSTMcolour_K_ss2+VSTMcolour_K_ss3+VSTMcolour_K_ss4
vstmlv~fa 1 +fa 2 +fa 3 +fa 4 +fa 5 +fa 6 +fa 7 +fa 8 +fa 9 +fa 10 +fa 11 +fa 12 +fa 13 +fa 14 +fa 15 +fa 16 +fa 17 +fa 18 +fa 19 +fa 20 +fa 21 +fa 22 +fa 23 +fa 24 +fa 25 +fa 26 +fa 27 +fa 28 +fa 29 +fa 30 +fa 31 +fa 32 +fa 33 +fa 34 +fa 35 +fa 36 +fa 37 +fa 38 +fa 39 +fa 40 +fa 41 +fa 42 +fa 43 +fa 44 +fa 45 +fa 46 +fa 47 +fa 48
'
fitvstm_WM <- cfa(vstmCFA_WM, data=data.std, estimator='mlr',missing='fiml')
summary(fitvstm_WM, fit.measures=TRUE, standardized=TRUE, rsquare=TRUE)
#regsem
lav.out_WM<-try(lavaan::sem(vstmCFA_WM,data.std,fixed.x=TRUE,meanstructure=FALSE),silent=TRUE)
A <- extractMatrices(lav.out_WM)$A
A[A!=0]
#cov.test= cov(data.test[,c(51:98,100:102)],use="complete.obs")
#tt = regsem(lav.out_WM)
# enet, alpha=0.5 has problems converging at higher than 15 lambdas at 0.075 jump
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=20,jump=.05,tol=1e-4,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=40,jump=.01,type="enet",alpha=0,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=40,jump=.01,type="enet",alpha=0.5,pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
reg.out1_WM
?cv_regsem
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=40,jump=.01,type="lasso",pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
reg.out1_WM
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=40,jump=.01,type="alasso",pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
library(regsem)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=40,jump=.01,type="lasso",pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
reg.out1_WM
library(regsem)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=40,jump=.01,type="lasso",pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=20,jump=.01,type="lasso",pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
reg.out1_WM
plot(reg.out1_WM)
library(regsem)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=20,jump=.01,type="lasso",pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM
library(regsem)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=20,jump=.01,type="lasso",pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM
library(regsem)
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=20,jump=.01,type="lasso",pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM
reg.out1_WM <- cv_regsem(lav.out_WM,n.lambda=30,jump=.01,type="lasso",pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
plot(reg.out1_WM)
reg.out1_WM
summary(reg.out1_WM,fit="BIC") # problem
reg.out1_WM[[2]][,"BIC"]
which(reg.out1_WM[[2]][,"BIC"] == min(reg.out1_WM[[2]][,"BIC"])
summary(reg.out1_WM,fit="BIC") # problem
which(reg.out1_WM[[2]][,"BIC"] == min(reg.out1_WM[[2]][,"BIC"]))
min(reg.out1_WM[[2]][,"BIC"])
which(reg.out1_WM[[2]][1:26,"BIC"] == min(reg.out1_WM[[2]][1:26,"BIC"]))
which(reg.out1_WM[[2]][1:25,"BIC"] == min(reg.out1_WM[[2]][1:25,"BIC"]))
reg.out1_WM[[1]][8,]
reg.out2_WM <- cv_regsem(lav.out_WM,n.lambda=30,jump=.02,type="enet",pars_pen=c(3:50),quasi=TRUE,
fit.ret=c("Fmin","chisq","ncp","BIC","rmsea"),fit.ret2="train",
mult.start=TRUE,solver=FALSE,hessFun="none")
which(reg.out2_WM[[2]][1:25,"BIC"] == min(reg.out2_WM[[2]][1:25,"BIC"]))
reg.out2_WM
which(reg.out2_WM[[2]][1:24,"BIC"] == min(reg.out2_WM[[2]][1:24,"BIC"]))
which(reg.out2_WM[[2]][1:24,"BIC"] == min(reg.out2_WM[[2]][1:24,"BIC"]))
reg.out2_WM[[1]][13,]
save.image("mimic_regsem_camcam_Jun16.RData")
library(regsem)
library(regsem)
sim.func <- function(vec){
library(regsem)
xx = list()
for(i in 1:70){
xx[i] = paste("x", i, sep = "")
}
uu = list()
for(i in 1:length(xx)){
uu[i] = paste("0*",xx[i],sep="")
}
reg.list = paste(uu,collapse="+")
sim.list = list()
sim.list[[1]] = "f1 =~ y1 + 0.8*y2 + 1.2*y3 + 0.8*y4 + 0.5*y5 + 1.5*y6
"
sim.list[[2]] = paste(paste("f1"," ~ "), reg.list)
sim.list[[3]] = "
f1 ~ 0.2*x71 + 0.2*x72 + 0.2*x73 + 0.2*x74 + 0.2*x75 + 0.2*x76 + 0.2*x77 + 0.2*x78 + 0.2*x79 + 0.2*x80
"
sim.list[[4]] = "
f1 ~ 0.5*x81 + 0.5*x82 + 0.5*x83 + 0.5*x84 + 0.5*x85 + 0.5*x86 + 0.5*x87 + 0.5*x88 + 0.5*x89 + 0.5*x90
"
sim.list[[5]] = "
f1 ~ 1*x91 + 1*x92 + 1*x93 + 1*x94 + 1*x95 + 1*x96 + 1*x97 + 1*x98 + 1*x99 + 1*x100
"
xxx = list()
for(i in 1:100){
xxx[i] = paste("x", i, sep = "")
}
#### create collinearity
#val = val # won't go above 0.5
uuu = list()
for(i in 1:(length(xxx)-1)){
uuu[i] = paste(xxx[i],"~~val*",xxx[i+1],sep="")
}
sim.list[[6]] = paste(uuu,collapse=";")
jjj = list()
for(i in 1:(length(xxx))){
jjj[i] = paste(xxx[i],"~~1*",xxx[i],sep="")
}
sim.list[[7]] = paste(jjj,collapse=";")
pop.mod = " "
for(i in 1:length(sim.list)){
pop.mod = paste(pop.mod,sim.list[[i]],sep="\n")
}
pop.mod2 = gsub("val",vec["val"],pop.mod)
reg.list2 = paste(xxx,collapse="+")
run.list = list()
run.list[[1]] = "f1 =~ y1 + y2 + y3 + y4 + y5 + y6
"
run.list[[2]] = paste(paste("f1"," ~ "), reg.list2)
run.mod = " "
for(k in 1:length(run.list)){
run.mod = paste(run.mod,run.list[[k]],sep="\n")
}
dat <- simulateData(pop.mod2,sample.nobs=vec["samp"],seed=vec["seed"],model.type="lavaan")
dat2 <- dat
dat2[,7:106] <- scale(dat[,7:106])
lav.out <- try(lavaan::sem(run.mod,dat2,fixed.x=TRUE),silent=TRUE)
#summary(lav.out)
mat <- extractMatrices(lav.out)["A"]
# options(max.print=10000000)
out <- regsem(lav.out,type="none")
system.time(enet.sim <- cv_regsem(lav.out,n.lambda=40,jump=.02,tol=1e-4,type="enet",
pars_pen=c(6:105),max.iter=400,multi.iter=3,quasi=TRUE,
fit.ret=c("BIC","rmsea","AIC","CAIC","EBIC.5","EBIC.25"),
fit.ret2="train",mult.start=TRUE))
list(enet.sim,lav.out,vec["samps"],vec["val"])
}
samp <- c(150)
val <- c(0.25)
iters <- 1:5
grid <- expand.grid(iters=iters,samp=samp,val=val)
grid$seed <- 1:nrow(grid)
library(parallel)
no_cores <- 5
cl <- makeCluster(no_cores)
clusterExport(cl, c("grid"))
ret <- parRapply(cl,grid,sim.func)
ret
